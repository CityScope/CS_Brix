

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>brix.classes &mdash; cs-brix 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> cs-brix
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">cs-brix</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>brix.classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for brix.classes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">webbrowser</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">pygeohash</span> <span class="k">as</span> <span class="nn">pgh</span>
<span class="kn">import</span> <span class="nn">joblib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">shape</span>
<span class="kn">from</span> <span class="nn">.helpers</span> <span class="kn">import</span> <span class="n">is_number</span><span class="p">,</span> <span class="n">get_buffer_size</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">unary_union</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">shape</span>

<span class="k">class</span> <span class="nc">GEOGRIDDATA</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Class to package the input needed by each indicator. </span>
<span class="sd">	This class extends a simple list to charge it with additional properties, if needed.</span>
<span class="sd">	It&#39;s mainly used for internal purposes. </span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	geogrid_data : list</span>
<span class="sd">		List to converg to GEOGRIDDATA object.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">GEOGRIDDATA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Invalid GEOGRIDDATA endpoint. You need to update your grid at least once. See Handler.reset_geogrid_data()&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">geogrid_props</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="k">def</span> <span class="nf">link_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">table_name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Sets geogrid using set_geogrid.</span>
<span class="sd">		This function should use if GEOGRIDDATA needs to be updated.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		table_name: str or :class:`brix.Handler`</span>
<span class="sd">			Name of the table or Handler object.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span><span class="n">Handler</span><span class="p">):</span>
			<span class="n">tableHandler</span> <span class="o">=</span> <span class="n">table_name</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">tableHandler</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">set_geogrid</span><span class="p">(</span><span class="n">tableHandler</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">())</span>

	<span class="k">def</span> <span class="nf">set_geogrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">GEOGRID</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="o">=</span> <span class="n">GEOGRID</span>

	<span class="k">def</span> <span class="nf">get_geogrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the value of GEOGRIDDATA from the corresponding :class:`brix.Handler`.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		GEOGRID : dict</span>
<span class="sd">			Value of GEOGRID</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span>

	<span class="k">def</span> <span class="nf">get_geogrid_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the value of :attr:`brix.Handler.geogrid_props` from the corresponding :class:`brix.Handler`.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		geogrid_props : dict or list</span>
<span class="sd">			Value of :attr:`brix.Handler.geogrid_props`</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">grid_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_geogrid</span><span class="p">()[</span><span class="s1">&#39;features&#39;</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">get_type_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_geogrid_props</span><span class="p">()[</span><span class="s1">&#39;types&#39;</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">get_type_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_geogrid_props</span><span class="p">()[</span><span class="s1">&#39;types&#39;</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">number_of_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_set</span><span class="p">())</span>

	<span class="k">def</span> <span class="nf">check_type_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quietly</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="n">non_defined_cells</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_set</span><span class="p">())</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_defined_cells</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">quietly</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unrecognized types:&#39;</span><span class="p">,</span><span class="n">non_defined_cells</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">False</span>

	<span class="k">def</span> <span class="nf">check_id_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">quietly</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="n">n_unique_ids</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]))</span>
		<span class="k">if</span> <span class="n">n_unique_ids</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">():</span>
			<span class="k">return</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">quietly</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of unique cells in geogrid_data does not match grid size&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">False</span>

	<span class="k">def</span> <span class="nf">remap_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Forces the colors to match the define colors of the cell type. </span>
<span class="sd">		Requires that GEOGRIDDATA is set</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;GEOGRIDDATA object does not have GEOGRID attribute.&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_type_validity</span><span class="p">(</span><span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Type not found in table definition.&#39;</span><span class="p">)</span>
		<span class="n">GEOGRID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span>
		<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="n">h</span> <span class="o">=</span> <span class="n">GEOGRID</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">][</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
			<span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
			<span class="n">cell</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

<div class="viewcode-block" id="Handler"><a class="viewcode-back" href="../../classes.html#brix.Handler">[docs]</a><span class="k">class</span> <span class="nc">Handler</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Class to handle the connection for indicators built based on data from the GEOGRID. To use, instantiate the class and use the :func:`~brix.Handler.add_indicator` method to pass it a set of :class:`~brix.Indicator` objects.</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	table_name : str</span>
<span class="sd">		Table name to lisen to.</span>
<span class="sd">		https://cityio.media.mit.edu/api/table/table_name</span>
<span class="sd">	GEOGRIDDATA_varname : str, defaults to `GEOGRIDDATA`</span>
<span class="sd">		Name of geogrid-data variable in the table API.</span>
<span class="sd">		The object located at:</span>
<span class="sd">		https://cityio.media.mit.edu/api/table/table_name/GEOGRIDDATA_varname</span>
<span class="sd">		will be used as input for the return_indicator function in each indicator class.</span>
<span class="sd">	GEOGRID_varname : str, defaults to `GEOGRID`</span>
<span class="sd">		Name of variable with geometries.</span>
<span class="sd">	quietly : boolean, defaults to `True`</span>
<span class="sd">		If True, it will show the status of every API call.</span>
<span class="sd">	reference : dict, optional</span>
<span class="sd">		Dictionary for reference values for each indicator.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> 
		<span class="n">GEOGRIDDATA_varname</span> <span class="o">=</span> <span class="s1">&#39;GEOGRIDDATA&#39;</span><span class="p">,</span> 
		<span class="n">GEOGRID_varname</span> <span class="o">=</span> <span class="s1">&#39;GEOGRID&#39;</span><span class="p">,</span> 
		<span class="n">quietly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
		<span class="n">host_mode</span> <span class="o">=</span><span class="s1">&#39;remote&#39;</span> <span class="p">,</span> 
		<span class="n">reference</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

		<span class="nb">super</span><span class="p">(</span><span class="n">Handler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">host_mode</span><span class="o">==</span><span class="s1">&#39;local&#39;</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;http://127.0.0.1:5000/&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;https://cityio.media.mit.edu/&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="o">=</span> <span class="n">table_name</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">quietly</span> <span class="o">=</span> <span class="n">quietly</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">sleep_time</span> <span class="o">=</span> <span class="mf">0.5</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">nAttempts</span> <span class="o">=</span> <span class="mi">5</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">append_on_post</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">front_end_url</span>   <span class="o">=</span> <span class="s1">&#39;https://cityscope.media.mit.edu/CS_cityscopeJS/?cityscope=&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="o">+</span><span class="s1">&#39;api/table/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">host</span><span class="o">+</span><span class="s1">&#39;api/table/update/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span>
		
		<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID_varname</span> <span class="o">=</span> <span class="n">GEOGRID_varname</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRIDDATA_varname</span> <span class="o">=</span> <span class="n">GEOGRIDDATA_varname</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">indicators</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_hash</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">previous_indicators</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">previous_access</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">none_character</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">geogrid_props</span><span class="o">=</span><span class="kc">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">reference</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">classification_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LBCS&#39;</span><span class="p">,</span><span class="s1">&#39;NAICS&#39;</span><span class="p">]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">OSM_data</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Handler.grid_bounds"><a class="viewcode-back" href="../../classes.html#brix.Handler.grid_bounds">[docs]</a>	<span class="k">def</span> <span class="nf">grid_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bbox</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">buffer_percent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the bounds of the geogrid.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		bbox: boolean, defaults to False</span>
<span class="sd">			If True, it will return a bounding box instead of a polygon.</span>
<span class="sd">		buffer_percent: float, optional</span>
<span class="sd">			If given, this will add a buffer around the table.</span>
<span class="sd">			Size of buffer in units of the grid diameter</span>
<span class="sd">			See :func:`brix.get_buffer_size`.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		limit: shapely.Polygon or list</span>
<span class="sd">			Bounds of the table. If `bbox=True` it will return a horizontal bounding box.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">(</span><span class="n">include_geometries</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

		<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">]</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">get_buffer_size</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span><span class="n">buffer_percent</span><span class="o">=</span><span class="mf">0.001</span><span class="p">))</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">buffer_percent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">buffer_size</span> <span class="o">=</span> <span class="n">get_buffer_size</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span><span class="n">buffer_percent</span><span class="o">=</span><span class="n">buffer_percent</span><span class="p">)</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">)</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">bbox</span><span class="p">:</span>
			<span class="n">lons</span><span class="p">,</span><span class="n">lats</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">limit</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">)]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">limit</span></div>

        
<div class="viewcode-block" id="Handler.check_table"><a class="viewcode-back" href="../../classes.html#brix.Handler.check_table">[docs]</a>	<span class="k">def</span> <span class="nf">check_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_value</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Prints the front end url for the table. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		return_value : boolean, defaults to `False`</span>
<span class="sd">			If `True` it will print and return the front end url.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		front_end_url : str</span>
<span class="sd">			Onlye if `return_value=True`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">front_end_url</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">return_value</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">front_end_url</span></div>

<div class="viewcode-block" id="Handler.see_current"><a class="viewcode-back" href="../../classes.html#brix.Handler.see_current">[docs]</a>	<span class="k">def</span> <span class="nf">see_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indicator_type</span><span class="o">=</span><span class="s1">&#39;numeric&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Returns the current values of the indicators posted for the table.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		indicator_type : str, defaults to `numeric`</span>
<span class="sd">			Type of the indicator. Choose either `numeric`, `access`, or `heatmap` (`access` and `heatmap` refer to the same type).</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		current_status: dict</span>
<span class="sd">			Current value of selected indicators.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">]:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/indicators&#39;</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/indicators&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">,</span><span class="s1">&#39;access&#39;</span><span class="p">]:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/access&#39;</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/access&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Indicator type should either be numeric, heatmap, or access. Current type: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">indicator_type</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cant access cityIO hashes&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Handler.list_indicators"><a class="viewcode-back" href="../../classes.html#brix.Handler.list_indicators">[docs]</a>	<span class="k">def</span> <span class="nf">list_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Returns list of all indicator names.</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		indicators_names : list</span>
<span class="sd">			List of indicator names.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">]</span></div>

<div class="viewcode-block" id="Handler.indicator"><a class="viewcode-back" href="../../classes.html#brix.Handler.indicator">[docs]</a>	<span class="k">def</span> <span class="nf">indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Returns the :class:`brix.Indicator` with the given name.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		name : str</span>
<span class="sd">			Name of the indicator. See :func:`brix.Handler.list_indicators`.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		selected_indicator : :class:`brix.Indicator`</span>
<span class="sd">			Selected indicator object.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="Handler.add_indicators"><a class="viewcode-back" href="../../classes.html#brix.Handler.add_indicators">[docs]</a>	<span class="k">def</span> <span class="nf">add_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indicator_list</span><span class="p">,</span><span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Same as :func:`brix.Handler.add_indicator` but it takes in a list of :class:`brix.Indicator` objects.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		indicator_list : list</span>
<span class="sd">			List of :class:`brix.Indicator` objects.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">indicator_list</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">)</span></div>

<div class="viewcode-block" id="Handler.add_indicator"><a class="viewcode-back" href="../../classes.html#brix.Handler.add_indicator">[docs]</a>	<span class="k">def</span> <span class="nf">add_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">test</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Adds indicator to handler object.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		I : :class:`brix.Indicator`</span>
<span class="sd">			Indicator object to handle. If indicator has name, this will use as identifier. If indicator has no name, it will generate an identifier.</span>
<span class="sd">		test : boolean, defaults to `True`</span>
<span class="sd">			If `True` it will ensure the indicator runs before adding it to the :class:`brix.Handler`. </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Indicator</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Indicator must be instance of Indicator class&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">indicatorName</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">name</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">indicatorName</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;0000&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span>

		<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">tableHandler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Indicator </span><span class="si">{indicatorName}</span><span class="s1"> has a table linked to it. Remember you do not need to link_table when using the Handler class&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">indicatorName</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Indicator </span><span class="si">{indicatorName}</span><span class="s1"> already exists and will be overwritten&#39;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicatorName</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
		<span class="k">if</span> <span class="n">test</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;numeric&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">,</span><span class="s1">&#39;access&#39;</span><span class="p">]):</span>
				<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Indicator type should either be numeric, heatmap, or access. Current type: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span><span class="p">))</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">:</span>
					<span class="n">indicator_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indicator_values</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">include_composite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">,</span><span class="n">indicatorName</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicatorName</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Indicator not working: &#39;</span><span class="o">+</span><span class="n">indicatorName</span><span class="p">)</span></div>

<div class="viewcode-block" id="Handler.return_indicator"><a class="viewcode-back" href="../../classes.html#brix.Handler.return_indicator">[docs]</a>	<span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Returns the unformatted value returned by :func:`brix.Indicator.return_indicator` function of the selected indicator.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		indicator_name : str</span>
<span class="sd">			Name or identifier of the indicator. See :func:`brix.Handler.list_indicators()`</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		indicator_value : dict or float</span>
<span class="sd">			Result of :func:`brix.Indicator.return_indicator` function for the selected indicator.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">()</span>
		<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">:</span>
			<span class="n">indicator_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indicator_values</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">include_composite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">I</span><span class="o">.</span><span class="n">return_indicator</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">I</span><span class="o">.</span><span class="n">return_indicator</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span></div>

	<span class="k">def</span> <span class="nf">_format_geojson</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_value</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Formats the result of the return_indicator function into a valid geojson (not a cityIO geojson)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;properties&#39;</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">dict</span><span class="p">)))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_number</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]]):</span>
				<span class="c1"># print(&#39;Type1B&#39;)</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
					<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># print(&#39;Type1&#39;)</span>
				<span class="k">pass</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">dict</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]]):</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
					<span class="n">feature_properties</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_properties</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]):</span>
						<span class="n">feature_properties</span><span class="o">+=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">none_character</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_properties</span><span class="p">))</span>
					<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_properties</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]):</span>
						<span class="n">feature_properties</span> <span class="o">=</span> <span class="n">feature_properties</span><span class="p">[:</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]]</span>
					<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="n">feature_properties</span><span class="p">))</span>
			<span class="n">new_value</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;properties&#39;</span><span class="p">)</span>

		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;features&#39;</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">dict</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]]):</span>
				<span class="c1"># print(&#39;Type2B&#39;)</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
					<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">indicator_name</span><span class="p">:</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]}</span>
			<span class="k">elif</span> <span class="nb">all</span><span class="p">([(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">dict</span><span class="p">))</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]]):</span>
				<span class="c1"># print(&#39;Type2C&#39;)</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
					<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">indicator_name</span><span class="p">:</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]}</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># print(&#39;Type2&#39;)</span>
				<span class="k">pass</span>

		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">]):</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">is_number</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">]):</span>
				<span class="c1"># print(&#39;Type3B&#39;)</span>
				<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">:</span>
					<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">indicator_name</span><span class="p">:</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]}</span>
			<span class="k">elif</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span><span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">]):</span>
				<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Indicator returned invalid geojson or feature list:&#39;</span><span class="o">+</span><span class="n">indicator_name</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="c1"># print(&#39;Type3&#39;)</span>
				<span class="k">pass</span>
			<span class="n">new_value</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;features&#39;</span><span class="p">:</span><span class="n">new_value</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;FeatureCollection&#39;</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Indicator returned invalid geojson or feature list:&#39;</span><span class="o">+</span><span class="n">indicator_name</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
			<span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_character</span><span class="p">,</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">new_value</span>

	<span class="k">def</span> <span class="nf">_new_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Formats the result of the indicator&#39;s return_indicator function.a</span>

<span class="sd">		If indicator is numeric, the result is formatted as:</span>
<span class="sd">			[</span>
<span class="sd">				{</span>
<span class="sd">					&#39;name&#39;:xxx, </span>
<span class="sd">					&#39;indicator_type&#39;:yyy, </span>
<span class="sd">					&#39;viz_type&#39;:zzz, </span>
<span class="sd">					&#39;value&#39;:value</span>
<span class="sd">				},</span>
<span class="sd">				{</span>
<span class="sd">					...</span>
<span class="sd">				},</span>
<span class="sd">				...</span>
<span class="sd">			]</span>
<span class="sd">		If indicator is access or heatmap, the result is formatted as a list of features:</span>
<span class="sd">			[</span>
<span class="sd">				feature1,</span>
<span class="sd">				feature2,</span>
<span class="sd">				...</span>
<span class="sd">			]</span>
<span class="sd">		with each feature formatted as:</span>
<span class="sd">			{</span>
<span class="sd">				&#39;geometry&#39;:{</span>
<span class="sd">								...</span>
<span class="sd">							},</span>
<span class="sd">				&#39;properties&#39;:{</span>
<span class="sd">								name: value,</span>
<span class="sd">								...</span>
<span class="sd">				}</span>
<span class="sd">			}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">]:</span>
			<span class="n">new_value</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">return_indicator</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
			<span class="n">new_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_geojson</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">new_value</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">]:</span>
			<span class="n">new_value</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">return_indicator</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span><span class="o">|</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_value</span><span class="p">)):</span>
					<span class="n">val</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
						<span class="k">try</span><span class="p">:</span>
							<span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
							<span class="n">new_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">val</span><span class="p">}</span>
						<span class="k">except</span><span class="p">:</span>
							<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Indicator return invalid type:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">indicator_name</span><span class="p">))</span>
					<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;indicator_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
						<span class="n">val</span><span class="p">[</span><span class="s1">&#39;indicator_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span>
					<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;viz_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">viz_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
						<span class="n">val</span><span class="p">[</span><span class="s1">&#39;viz_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">viz_type</span>
				<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_value</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
					<span class="k">try</span><span class="p">:</span>
						<span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">new_value</span><span class="p">)</span>
						<span class="n">new_value</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">new_value</span><span class="p">}</span>
					<span class="k">except</span><span class="p">:</span>
						<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Indicator return invalid type:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">indicator_name</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
					<span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indicator_name</span>
				<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;indicator_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
					<span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;indicator_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span>
				<span class="k">if</span> <span class="p">(</span><span class="s1">&#39;viz_type&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_value</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">viz_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
					<span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;viz_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">viz_type</span>
				<span class="k">return</span> <span class="p">[</span><span class="n">new_value</span><span class="p">]</span>


	<span class="k">def</span> <span class="nf">_combine_heatmap_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_values_heatmap</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Combines a list of heatmap features (formatted as geojsons) into one cityIO GeoJson</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">all_properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
		<span class="n">combined_features</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">new_values_heatmap</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">]:</span>
				<span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Point&#39;</span><span class="p">:</span>
					<span class="n">all_properties</span> <span class="o">=</span> <span class="n">all_properties</span><span class="o">|</span><span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
					<span class="n">lon</span><span class="p">,</span><span class="n">lat</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>
					<span class="n">hashed</span> <span class="o">=</span> <span class="n">pgh</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">)</span>
					
					<span class="k">if</span> <span class="n">hashed</span> <span class="ow">in</span> <span class="n">combined_features</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
						<span class="n">combined_features</span><span class="p">[</span><span class="n">hashed</span><span class="p">][</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">combined_features</span><span class="p">[</span><span class="n">hashed</span><span class="p">][</span><span class="s1">&#39;properties&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]}</span> 
						<span class="n">combined_features</span><span class="p">[</span><span class="n">hashed</span><span class="p">][</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_character</span><span class="p">,</span><span class="n">combined_features</span><span class="p">[</span><span class="n">hashed</span><span class="p">][</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">combined_features</span><span class="p">[</span><span class="n">pgh</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">)]</span> <span class="o">=</span> <span class="n">f</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Only Points supported at this point&#39;</span><span class="p">)</span>
		<span class="n">all_properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_properties</span><span class="p">)</span>
		<span class="n">combined_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combined_features</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">combined_features</span><span class="p">:</span>
			<span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_properties</span><span class="p">]</span>

		<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;FeatureCollection&#39;</span><span class="p">,</span><span class="s1">&#39;properties&#39;</span><span class="p">:</span><span class="n">all_properties</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">:</span><span class="n">combined_features</span><span class="p">}</span>

<div class="viewcode-block" id="Handler.get_indicator_values"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_indicator_values">[docs]</a>	<span class="k">def</span> <span class="nf">get_indicator_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">include_composite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the current values of numeric indicators. Used for developing a composite indicator.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		include_composite : boolean, defaults to `False`</span>
<span class="sd">			If `True` it will also include the composite indicators, using the :class:`brix.Indicator` `is_composite` parameter. </span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		indicator_values : dict</span>
<span class="sd">			Dictionary with values for each indicator formatted as: ``{indicator_name: indicator_value, ...}``</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">geogrid_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">()</span>
		<span class="n">new_values_numeric</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">indicator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">:</span>
			<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">):</span>
				<span class="n">new_values_numeric</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>
		<span class="n">indicator_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_values_numeric</span><span class="p">}</span>
		<span class="k">if</span> <span class="n">include_composite</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">indicator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">:</span>
				<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">):</span>
					<span class="n">new_values_numeric</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>
		<span class="n">indicator_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_values_numeric</span><span class="p">}</span>
		<span class="k">return</span> <span class="n">indicator_values</span></div>

<div class="viewcode-block" id="Handler.update_package"><a class="viewcode-back" href="../../classes.html#brix.Handler.update_package">[docs]</a>	<span class="k">def</span> <span class="nf">update_package</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the package that will be posted in CityIO.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		geogrid_data : dict, optional</span>
<span class="sd">			Result of :func:`brix.Handler.get_geogrid_data`. If not provided, it will be retrieved. </span>
<span class="sd">		append : boolean, defaults to `False`</span>
<span class="sd">			If True, it will append the new indicators to whatever is already there.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new_values : list</span>
<span class="sd">			Note that all heatmat indicators have been grouped into just one value.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">geogrid_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">()</span>
		<span class="n">new_values_numeric</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">new_values_heatmap</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="k">for</span> <span class="n">indicator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>
				<span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">]:</span>
					<span class="n">new_values_heatmap</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>
				<span class="k">elif</span> <span class="ow">not</span> <span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">:</span>
					<span class="n">new_values_numeric</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Indicator not working:&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">indicator_name</span><span class="p">))</span>

		<span class="k">for</span> <span class="n">indicator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">:</span>
			<span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">is_composite</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">]):</span>
				<span class="n">indicator_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_values_numeric</span><span class="p">}</span>
				<span class="n">new_values_numeric</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>

		<span class="c1"># add ref values if they exist</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">new_values_numeric</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="p">:</span>
					<span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;ref_value&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference</span><span class="p">[</span><span class="n">new_value</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>
		
		<span class="k">if</span> <span class="n">append</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_values_numeric</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">see_current</span><span class="p">()</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">previous_indicators</span> <span class="o">=</span> <span class="n">current</span>
				<span class="n">current</span> <span class="o">=</span> <span class="p">[</span><span class="n">indicator</span> <span class="k">for</span> <span class="n">indicator</span> <span class="ow">in</span> <span class="n">current</span> <span class="k">if</span> <span class="n">indicator</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
				<span class="n">new_values_numeric</span> <span class="o">+=</span> <span class="n">current</span>

			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_values_heatmap</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
				<span class="n">current_access</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">see_current</span><span class="p">(</span><span class="n">indicator_type</span><span class="o">=</span><span class="s1">&#39;access&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">previous_access</span> <span class="o">=</span> <span class="n">current_access</span>
				<span class="n">current_access</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_geojson</span><span class="p">(</span><span class="n">current_access</span><span class="p">)</span>
				<span class="n">new_values_heatmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_access</span><span class="p">]</span><span class="o">+</span><span class="n">new_values_heatmap</span>

		<span class="n">new_values_heatmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_heatmap_values</span><span class="p">(</span><span class="n">new_values_heatmap</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;numeric&#39;</span><span class="p">:</span><span class="n">new_values_numeric</span><span class="p">,</span><span class="s1">&#39;heatmap&#39;</span><span class="p">:</span><span class="n">new_values_heatmap</span><span class="p">}</span></div>
		
<div class="viewcode-block" id="Handler.test_indicators"><a class="viewcode-back" href="../../classes.html#brix.Handler.test_indicators">[docs]</a>	<span class="k">def</span> <span class="nf">test_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Dry run over all indicators.&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">indicator_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="p">[</span><span class="n">indicator_name</span><span class="p">]</span><span class="o">.</span><span class="n">is_composite</span><span class="p">:</span>
				<span class="n">indicator_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indicator_values</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">include_composite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_new_value</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">indicator_name</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="Handler.get_geogrid_props"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_geogrid_props">[docs]</a>	<span class="k">def</span> <span class="nf">get_geogrid_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Gets the `GEOGRID` properties defined for the table. These properties are not dynamic and include things such as the NAICS and LBCS composition of each lego type.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		geogrid_props : dict</span>
<span class="sd">			Table GEOGRID properties.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geogrid_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">geogrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">geogrid_props</span> <span class="o">=</span> <span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geogrid_props</span></div>

<div class="viewcode-block" id="Handler.get_table_properties"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_table_properties">[docs]</a>	<span class="k">def</span> <span class="nf">get_table_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Gets table properties. This info can also be accessed through :func:`brix.Handler.get_geogrid_props`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_geogrid_props</span><span class="p">()[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Handler.get_grid_hash"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_grid_hash">[docs]</a>	<span class="k">def</span> <span class="nf">get_grid_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Retreives the GEOGRID hash from:</span>
<span class="sd">		http://cityio.media.mit.edu/api/table/table_name/meta/hashes</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/meta/hashes&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">:</span>
			<span class="n">hashes</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">grid_hash_id</span> <span class="o">=</span> <span class="n">hashes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">GEOGRIDDATA_varname</span><span class="p">]</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: Table does not have a &#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">GEOGRIDDATA_varname</span><span class="o">+</span><span class="s1">&#39; variable.&#39;</span><span class="p">)</span>
				<span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Cant access cityIO hashes&#39;</span><span class="p">)</span>
			<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">grid_hash_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span>
		<span class="k">return</span> <span class="n">grid_hash_id</span></div>

<div class="viewcode-block" id="Handler.get_GEOGRID"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_GEOGRID">[docs]</a>	<span class="k">def</span> <span class="nf">get_GEOGRID</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID_varname</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">:</span>
				<span class="n">geogrid</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">geogrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_classifications</span><span class="p">(</span><span class="n">geogrid</span><span class="p">)</span>
				<span class="k">except</span><span class="p">:</span>
					<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;NAICS and LBCS classifications were not properly parsed.&#39;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span> <span class="o">=</span> <span class="n">geogrid</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: Cant access GEOGRIDDATA&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GEOGRID</span></div>

<div class="viewcode-block" id="Handler.normalize_codes"><a class="viewcode-back" href="../../classes.html#brix.Handler.normalize_codes">[docs]</a>	<span class="k">def</span> <span class="nf">normalize_codes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">code_proportion</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Helper function to transform:</span>
<span class="sd">		[{&#39;proportion&#39;: 0.3, &#39;use&#39;: {&#39;6700&#39;: 1}}, {&#39;proportion&#39;: 0.7, &#39;use&#39;: {&#39;2310&#39;: 0.3, &#39;4100&#39;: 0.7}}]</span>

<span class="sd">		into:</span>
<span class="sd">		{&#39;6700&#39;: 0.3, &#39;2310&#39;: 0.21, &#39;4100&#39;: 0.49}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">new_code_proportion</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">code_proportion</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">[</span><span class="s1">&#39;use&#39;</span><span class="p">]:</span>
				<span class="n">new_code_proportion</span><span class="p">[</span><span class="n">code</span><span class="p">]</span><span class="o">+=</span> <span class="nb">round</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">prop</span><span class="p">[</span><span class="s1">&#39;use&#39;</span><span class="p">][</span><span class="n">code</span><span class="p">],</span><span class="mi">5</span><span class="p">)</span>
		<span class="n">new_code_proportion</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">new_code_proportion</span><span class="p">)</span>
		<span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">new_code_proportion</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="n">new_code_proportion</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">new_code_proportion</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">total</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_code_proportion</span><span class="p">}</span>
		<span class="k">return</span> <span class="n">new_code_proportion</span></div>

<div class="viewcode-block" id="Handler.parse_classifications"><a class="viewcode-back" href="../../classes.html#brix.Handler.parse_classifications">[docs]</a>	<span class="k">def</span> <span class="nf">parse_classifications</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Helper function to parse the LBCS and NAICS strings into dictionaries of the form:</span>
<span class="sd">		{&#39;6700&#39;: 0.3, &#39;2310&#39;: 0.21, &#39;4100&#39;: 0.49}</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">]:</span>
			<span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_list</span><span class="p">:</span>
				<span class="n">code_proportion</span> <span class="o">=</span> <span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">code</span><span class="p">]</span>	
				<span class="k">if</span> <span class="p">(</span><span class="n">code_proportion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">code_proportion</span> <span class="o">!=</span><span class="s1">&#39;null&#39;</span><span class="p">):</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">code</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
						<span class="n">code_proportion</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">code</span><span class="p">])</span>
					<span class="n">code_proportion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_codes</span><span class="p">(</span><span class="n">code_proportion</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">code_proportion</span> <span class="o">=</span> <span class="kc">None</span>
				<span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;types&#39;</span><span class="p">][</span><span class="n">t</span><span class="p">][</span><span class="n">code</span><span class="p">]</span> <span class="o">=</span> <span class="n">code_proportion</span>
		<span class="k">return</span> <span class="n">geogrid</span></div>

<div class="viewcode-block" id="Handler.get_GEOGRIDDATA"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_GEOGRIDDATA">[docs]</a>	<span class="k">def</span> <span class="nf">get_GEOGRIDDATA</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the raw GEOGRIDDATA object.</span>
<span class="sd">		This function should be treated as a low-level function, please use :func:`brix.Handler.get_geogrid_data` instead.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_get_url</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">GEOGRIDDATA_varname</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">json</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: Cant access GEOGRIDDATA&#39;</span><span class="p">)</span>
			<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="n">geogrid_data</span></div>

	<span class="k">def</span> <span class="nf">_get_grid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">include_geometries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">with_properties</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRIDDATA</span><span class="p">()</span>
		<span class="n">geogrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">()</span>
	
		<span class="k">if</span> <span class="n">include_geometries</span><span class="o">|</span><span class="nb">any</span><span class="p">([</span><span class="n">I</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)):</span>
				<span class="n">geogrid_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">()[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">with_properties</span><span class="o">|</span><span class="nb">any</span><span class="p">([</span><span class="n">I</span><span class="o">.</span><span class="n">requires_geogrid_props</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicators</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
			<span class="n">geogrid_props</span> <span class="o">=</span> <span class="n">geogrid</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
			<span class="n">types_def</span> <span class="o">=</span> <span class="n">geogrid_props</span><span class="p">[</span><span class="s1">&#39;types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="k">if</span> <span class="s1">&#39;static_types&#39;</span> <span class="ow">in</span> <span class="n">geogrid_props</span><span class="p">:</span>
				<span class="n">types_def</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">geogrid_props</span><span class="p">[</span><span class="s1">&#39;static_types&#39;</span><span class="p">])</span>
			<span class="n">types_def</span><span class="p">[</span><span class="s1">&#39;None&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
				<span class="n">cell</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">types_def</span><span class="p">[</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">GEOGRIDDATA</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
		<span class="n">geogrid_data</span><span class="o">.</span><span class="n">set_geogrid</span><span class="p">(</span><span class="n">geogrid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">geogrid_data</span>

	<span class="k">def</span> <span class="nf">_get_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">url</span><span class="p">,</span><span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">attempts</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAttempts</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">success</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
				<span class="nb">print</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="s1">&#39;Attempt:&#39;</span><span class="p">,</span><span class="n">attempts</span><span class="p">)</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">status_code</span><span class="o">==</span><span class="mi">200</span><span class="p">:</span>
				<span class="n">success</span><span class="o">=</span><span class="kc">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">attempts</span><span class="o">+=</span><span class="mi">1</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
			<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;FAILED TO RETRIEVE URL: &#39;</span><span class="o">+</span><span class="n">url</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">r</span>

<div class="viewcode-block" id="Handler.get_geogrid_data"><a class="viewcode-back" href="../../classes.html#brix.Handler.get_geogrid_data">[docs]</a>	<span class="k">def</span> <span class="nf">get_geogrid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">include_geometries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">with_properties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">as_df</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the geogrid data from:</span>
<span class="sd">		http://cityio.media.mit.edu/api/table/table_name/GEOGRIDDATA</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		include_geometries : boolean, defaults to `False`</span>
<span class="sd">			If `True` it will also add the geometry information for each grid unit.</span>
<span class="sd">		with_properties : boolean, defaults to `False`</span>
<span class="sd">			If `True` it will add the properties of each grid unit as defined when the table was constructed (e.g. LBCS code, NAICS code, etc.)</span>
<span class="sd">		as_df: boolean, defaults to `False`</span>
<span class="sd">			If `True` it will return data as a pandas.DataFrame.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		geogrid_data : dict</span>
<span class="sd">			Data taken directly from the table to be used as input for :class:`brix.Indicator.return_indicator`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">(</span><span class="n">include_geometries</span><span class="o">=</span><span class="n">include_geometries</span><span class="p">,</span><span class="n">with_properties</span><span class="o">=</span><span class="n">with_properties</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">as_df</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
				<span class="k">if</span> <span class="s1">&#39;properties&#39;</span> <span class="ow">in</span> <span class="n">cell</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
					<span class="n">cell_props</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
					<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cell_props</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">cell_props</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_list</span><span class="p">:</span>
								<span class="n">cell</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;property_</span><span class="si">{k}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_props</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
							<span class="k">else</span><span class="p">:</span>
								<span class="k">for</span> <span class="n">code</span> <span class="ow">in</span> <span class="n">cell_props</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
									<span class="n">cell</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{k}</span><span class="s1">_</span><span class="si">{code}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_props</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">code</span><span class="p">]</span>
					<span class="k">del</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
			<span class="n">columns_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_list</span><span class="p">]</span>
			<span class="n">columns_order</span><span class="o">+=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">classification_list</span><span class="p">])</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">geogrid_data</span><span class="p">[</span><span class="n">columns_order</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">include_geometries</span><span class="p">:</span>
				<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">geometry</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

		<span class="k">return</span> <span class="n">geogrid_data</span></div>

<div class="viewcode-block" id="Handler.perform_update"><a class="viewcode-back" href="../../classes.html#brix.Handler.perform_update">[docs]</a>	<span class="k">def</span> <span class="nf">perform_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grid_hash_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Performs single table update.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		grid_hash_id : str, optional</span>
<span class="sd">			Current grid hash id. If not provided, it will retrieve it.</span>
<span class="sd">		append : boolean, defaults to `True`</span>
<span class="sd">			If `True`, it will append the new indicators to whatever is already there.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">grid_hash_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
			<span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_hash</span><span class="p">()</span>	
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Updating table with hash:&#39;</span><span class="p">,</span><span class="n">grid_hash_id</span><span class="p">)</span>

		<span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_package</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="n">append</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>

			<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/indicators&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">]))</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">][</span><span class="s1">&#39;features&#39;</span><span class="p">])</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/access&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">]))</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done with update&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span> <span class="o">=</span> <span class="n">grid_hash_id</span></div>

<div class="viewcode-block" id="Handler.rollback"><a class="viewcode-back" href="../../classes.html#brix.Handler.rollback">[docs]</a>	<span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;:class:`brix.Handler` keeps track of the previous value of the indicators and access values.This function rollsback the current values to whatever the locally stored values are.</span>
<span class="sd">		See also :func:`brix.Handler.previous_indicators` and :func:`brix.Handler.previous_access`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/indicators&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_indicators</span><span class="p">))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/access&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_access</span><span class="p">))</span></div>

<div class="viewcode-block" id="Handler.clear_table"><a class="viewcode-back" href="../../classes.html#brix.Handler.clear_table">[docs]</a>	<span class="k">def</span> <span class="nf">clear_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Clears all indicators from the table.&#39;&#39;&#39;</span>
		<span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_hash</span><span class="p">()</span>
		<span class="n">empty_update</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;numeric&#39;</span><span class="p">:</span> <span class="p">[],</span><span class="s1">&#39;heatmap&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;FeatureCollection&#39;</span><span class="p">,</span> <span class="s1">&#39;properties&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="p">[]}}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/indicators&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">empty_update</span><span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">]))</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/access&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">empty_update</span><span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">]))</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cleared table&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span> <span class="o">=</span> <span class="n">grid_hash_id</span></div>

	<span class="k">def</span> <span class="nf">_listen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">showFront</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Lower level listen. Should only be called directly for debugging purposes. </span>
<span class="sd">		Use :func:`brix.Handler.listen` instead.</span>

<span class="sd">		Listens for changes in the table&#39;s geogrid and update all indicators accordingly. </span>
<span class="sd">		You can use the update_package method to see the object that will be posted to the table.</span>
<span class="sd">		This method starts with an update before listening.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		showFront : boolean, defaults to `True`</span>
<span class="sd">			If `True` it will open the front-end URL in a webbrowser at start.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Table URL:&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">front_end_url</span><span class="p">)</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Testing indicators&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">test_indicators</span><span class="p">()</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Performing initial update&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">perform_update</span><span class="p">(</span><span class="n">append</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">append_on_post</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">showFront</span><span class="p">:</span>
			<span class="n">webbrowser</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">front_end_url</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
			<span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sleep_time</span><span class="p">)</span>
			<span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_hash</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">grid_hash_id</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">perform_update</span><span class="p">(</span><span class="n">grid_hash_id</span><span class="o">=</span><span class="n">grid_hash_id</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">append_on_post</span><span class="p">)</span>

<div class="viewcode-block" id="Handler.run"><a class="viewcode-back" href="../../classes.html#brix.Handler.run">[docs]</a>	<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Run method to be called by :func:`threading.Thread.start`. </span>
<span class="sd">		It runs :func:`brix.Handler._listen`.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_listen</span><span class="p">(</span><span class="n">showFront</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Handler.listen"><a class="viewcode-back" href="../../classes.html#brix.Handler.listen">[docs]</a>	<span class="k">def</span> <span class="nf">listen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_thread</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">showFront</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Listens for changes in the table&#39;s geogrid and update all indicators accordingly. </span>
<span class="sd">		You can use the update_package method to see the object that will be posted to the table.</span>
<span class="sd">		This method starts with an update before listening.</span>
<span class="sd">		Can run in a separate thread.</span>
<span class="sd">		Does not support updating GEOGRIDDATA.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		new_thread : boolean, defaults to `False`.</span>
<span class="sd">			If `True` it will run in a separate thread, freeing up the main thread for other tables.</span>
<span class="sd">			We recommend setting this to `False` when debugging, to avoid needing to recreate the object. </span>
<span class="sd">		showFront : boolean, defaults to `True`</span>
<span class="sd">			If `True` it will open the front-end URL in a webbrowser at start.</span>
<span class="sd">			Only works if `new_tread=False`.</span>
<span class="sd">		append : boolean, defaults to `False`</span>
<span class="sd">			If `True` it will append the new indicators to whatever is already there.</span>
<span class="sd">			This option will be deprecated soon. We recommend not using it unless strictly necessary.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">append_on_post</span> <span class="o">=</span> <span class="n">append</span>
		<span class="k">if</span> <span class="n">new_thread</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_listen</span><span class="p">(</span><span class="n">showFront</span><span class="o">=</span><span class="n">showFront</span><span class="p">)</span></div>

<div class="viewcode-block" id="Handler.reset_geogrid_data"><a class="viewcode-back" href="../../classes.html#brix.Handler.reset_geogrid_data">[docs]</a>	<span class="k">def</span> <span class="nf">reset_geogrid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Resets the GEOGRIDDATA endpoint to the initial value.</span>
<span class="sd">		If the GEOGRIDDATA has not been updated, this will update it. </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">()[</span><span class="s1">&#39;features&#39;</span><span class="p">]):</span>
			<span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
			<span class="n">cell</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
			<span class="n">geogrid_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">post_geogrid_data</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Handler.post_geogrid_data"><a class="viewcode-back" href="../../classes.html#brix.Handler.post_geogrid_data">[docs]</a>	<span class="k">def</span> <span class="nf">post_geogrid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Posts the given geogrid_data object, ensuring that the object is valid.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">GEOGRIDDATA</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
		<span class="n">geogrid_data</span><span class="o">.</span><span class="n">set_geogrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_GEOGRID</span><span class="p">())</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">geogrid_data</span><span class="o">.</span><span class="n">check_type_validity</span><span class="p">(</span><span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Type not found in table definition.&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">geogrid_data</span><span class="o">.</span><span class="n">check_id_validity</span><span class="p">():</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;IDs do not match.&#39;</span><span class="p">)</span>

		<span class="n">geogrid_data</span><span class="o">.</span><span class="n">remap_colors</span><span class="p">()</span>

		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cityIO_post_url</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">GEOGRIDDATA_varname</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">grid_hash_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_grid_hash</span><span class="p">()</span></div>


<div class="viewcode-block" id="Handler.update_geogrid_data"><a class="viewcode-back" href="../../classes.html#brix.Handler.update_geogrid_data">[docs]</a>	<span class="k">def</span> <span class="nf">update_geogrid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Function to update table GEOGRIDDATA.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		update_func : function</span>
<span class="sd">			Function to update the geogriddadata (list of dicts)</span>
<span class="sd">			Function should take a :class:`brix.Handler` as the first and only positional argument plus any number of keyword arguments.</span>
<span class="sd">			Function should return a list of dicts that represents a valid geogriddata object.</span>

<span class="sd">		Example</span>
<span class="sd">		-------</span>
<span class="sd">		&gt;&gt;&gt; def add_height(geogrid_data, levels):</span>
<span class="sd">				for cell in geogrid_data:</span>
<span class="sd">					cell[&#39;height&#39;] += levels</span>
<span class="sd">				return geogrid_data</span>
<span class="sd">		&gt;&gt;&gt; H = Handler(&#39;tablename&#39;, quietly=False)</span>
<span class="sd">		&gt;&gt;&gt; H.update_landuse(add_height)</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">new_geogrid_data</span> <span class="o">=</span> <span class="n">update_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">post_geogrid_data</span><span class="p">(</span><span class="n">new_geogrid_data</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">quietly</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done with update&#39;</span><span class="p">)</span></div></div>



<div class="viewcode-block" id="Indicator"><a class="viewcode-back" href="../../classes.html#brix.Indicator">[docs]</a><span class="k">class</span> <span class="nc">Indicator</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;Parent class to build indicators from. To use, you need to define a subclass than inherets properties from this class. Doing so, ensures your indicator inherets the necessary methods and properties to connect with a CityScipe table.&#39;&#39;&#39;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="o">=</span> <span class="s1">&#39;numeric&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">viz_type</span> <span class="o">=</span> <span class="s1">&#39;radar&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">requires_geogrid_props</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">model_path</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pickled_model</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="c1"># self.int_types_def=None</span>
		<span class="c1"># self.types_def=None</span>
		<span class="c1"># self.geogrid_header=None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">is_composite</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span><span class="s1">&#39;model_path&#39;</span><span class="p">,</span><span class="s1">&#39;requires_geometry&#39;</span><span class="p">,</span><span class="s1">&#39;indicator_type&#39;</span><span class="p">,</span><span class="s1">&#39;viz_type&#39;</span><span class="p">,</span><span class="s1">&#39;requires_geogrid_props&#39;</span><span class="p">]:</span>
			<span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">,</span><span class="s1">&#39;access&#39;</span><span class="p">]:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">viz_type</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">load_module</span><span class="p">()</span>
		<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
			<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;heatmap&#39;</span><span class="p">,</span><span class="s1">&#39;access&#39;</span><span class="p">]):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">return_indicator_user</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="Indicator.setup"><a class="viewcode-back" href="../../classes.html#brix.Indicator.setup">[docs]</a>	<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;User defined function. Used to set up the main attributed of the custom indicator. Acts similar to an `__init__` method.&#39;&#39;&#39;</span>
		<span class="k">pass</span></div>

<div class="viewcode-block" id="Indicator.return_indicator"><a class="viewcode-back" href="../../classes.html#brix.Indicator.return_indicator">[docs]</a>	<span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;User defined function. This function defines the value of the indicator as a function of the table state passed as `geogrid_data`. Function must return either a dictionary, a list, or a number. When returning a dict follow the format: ``{&#39;name&#39;: &#39;Indicator_NAME&#39;, &#39;value&#39;: 1.00}``. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		geogrid_data : dict</span>
<span class="sd">			Current state of the table. See :func:`brix.Indicator.get_geogrid_data` and :func:`brix.Handler.get_geogrid_data`. The content of this object will depend on the needs of the indicator. In particular, the values of :attr:`brix.Indicator.requires_geometry` and :attr:`brix.Indicator.requires_geogrid_props`.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		indicator_value : list, dict, or float</span>
<span class="sd">			Value of indicator or list of values. When returning a dict, please use the format ``{&#39;name&#39;: &#39;Indicator Name&#39;, &#39;value&#39;: indicator_value}``. When returning a list, please return a list of dictionaries in the same format. </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_indicator_user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_indicator_user</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Indicator.set_return_indicator"><a class="viewcode-back" href="../../classes.html#brix.Indicator.set_return_indicator">[docs]</a>	<span class="k">def</span> <span class="nf">set_return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_indicator</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Used to set the return_indicator method by passing a function.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		return_indicator: func</span>
<span class="sd">			Function that takes `geogrid_data` as input.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">return_indicator_user</span> <span class="o">=</span> <span class="n">return_indicator</span></div>


<div class="viewcode-block" id="Indicator.load_module"><a class="viewcode-back" href="../../classes.html#brix.Indicator.load_module">[docs]</a>	<span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;User defined function. Used to load any data necessary for the indicator to run. In principle, you could do everything using :func:`brix.Indicator.setup` but we encourage to separte data loading and module definition into two functions.&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">pickled_model</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_path</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Indicator.return_baseline"><a class="viewcode-back" href="../../classes.html#brix.Indicator.return_baseline">[docs]</a>	<span class="k">def</span> <span class="nf">return_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;User defined function. Used to return a baseline value.</span>
<span class="sd">		[This function might get deprecated]</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="kc">None</span></div>


	<span class="k">def</span> <span class="nf">_transform_geogrid_data_to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Transform the geogrid_data to a DataFrame to be used by a pickled model.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
		<span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">geometry</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">geogrid_data</span>

<div class="viewcode-block" id="Indicator.link_table"><a class="viewcode-back" href="../../classes.html#brix.Indicator.link_table">[docs]</a>	<span class="k">def</span> <span class="nf">link_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">table_name</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Creates a :class:`brix.Handler` and links the table to the indicator. This function should be used only for developing the indicator. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		table_name: str or :class:`brix.Handler`</span>
<span class="sd">			Name of the table or Handler object.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;Please provide a table_name to link&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">table_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">table_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span><span class="n">Handler</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="o">=</span> <span class="n">table_name</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Indicator.get_table_properties"><a class="viewcode-back" href="../../classes.html#brix.Indicator.get_table_properties">[docs]</a>	<span class="k">def</span> <span class="nf">get_table_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Gets table properties from the linked table. See :func:`brix.Indicator.link_table` and :func:`brix.Handler.get_table_properties`.&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;No table linked: use Indicator.link_table(table_name)&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span><span class="o">.</span><span class="n">get_geogrid_props</span><span class="p">()[</span><span class="s1">&#39;header&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="Indicator.get_geogrid_data"><a class="viewcode-back" href="../../classes.html#brix.Indicator.get_geogrid_data">[docs]</a>	<span class="k">def</span> <span class="nf">get_geogrid_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">as_df</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">include_geometries</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">with_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the geogrid data from the linked table. Function mainly used for development. See :func:`brix.Indicator.link_table`. It returns the exact object that will be passed to return_indicator</span>


<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		as_df: boolean, defaults to `False`</span>
<span class="sd">			If `True` it will return data as a pandas.DataFrame.</span>
<span class="sd">		include_geometries: boolean, defaults to :attr:`brix.Indicator.requires_geometry`</span>
<span class="sd">			If `True`, it will override the default parameter of the Indicator.</span>
<span class="sd">		with_properties: boolean, defaults to :attr:`brix.Indicator.requires_geogrid_props`</span>
<span class="sd">			If `True`, it will override the default parameter of the Indicator.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		geogrid_data : str or pandas.DataFrame</span>
<span class="sd">			Data that will be passed to the :func:`brix.Indicator.return_indicator` function by the :class:`brix.Handler` when deployed.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">include_geometries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="k">if</span> <span class="n">include_geometries</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">include_geometries</span>
		<span class="n">with_properties</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">requires_geogrid_props</span> <span class="k">if</span> <span class="n">with_properties</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">with_properties</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">link_table</span><span class="p">(</span><span class="n">table_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">warn</span><span class="p">(</span><span class="s1">&#39;To use this function, please link a table first:</span><span class="se">\n</span><span class="s1">&gt; Indicator.link_table(table_name)&#39;</span><span class="p">)</span>
				<span class="k">return</span> <span class="kc">None</span>

		<span class="n">geogrid_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableHandler</span><span class="o">.</span><span class="n">_get_grid_data</span><span class="p">(</span><span class="n">include_geometries</span><span class="o">=</span><span class="n">include_geometries</span><span class="p">,</span><span class="n">with_properties</span><span class="o">=</span><span class="n">with_properties</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">as_df</span><span class="p">:</span>
			<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">include_geometries</span><span class="p">:</span>
				<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geogrid_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">geometry</span><span class="o">=</span><span class="n">geogrid_data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">geogrid_data</span></div></div>


<div class="viewcode-block" id="CompositeIndicator"><a class="viewcode-back" href="../../classes.html#brix.CompositeIndicator">[docs]</a><span class="k">class</span> <span class="nc">CompositeIndicator</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;Subclass used to define composite indicators. Composite indicators are functions of already defined indicators. By defining :func:`brix.Indicator.setup` and :func:`brix.Indicator.return_indicator`, this class allows you to define a composite indicator by just passing an aggregation function.&#39;&#39;&#39;</span>
<div class="viewcode-block" id="CompositeIndicator.setup"><a class="viewcode-back" href="../../classes.html#brix.CompositeIndicator.setup">[docs]</a>	<span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compose_function</span><span class="p">,</span><span class="n">selected_indicators</span><span class="o">=</span><span class="p">[],</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Indicator setup. This function is called upon `__init__` so user does not need to call it independently.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		compose_function : function</span>
<span class="sd">			Function to aggregate values of selected indicators. The function should be build to accept a dictionary with indicator values. See :func:`brix.Handler.get_indicator_values`. </span>
<span class="sd">		selected_indicators : list, optional</span>
<span class="sd">			List of indicators to use to aggregate. </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">compose_function</span> <span class="o">=</span> <span class="n">compose_function</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">is_composite</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">selected_indicators</span> <span class="o">=</span> <span class="n">selected_indicators</span></div>

<div class="viewcode-block" id="CompositeIndicator.return_indicator"><a class="viewcode-back" href="../../classes.html#brix.CompositeIndicator.return_indicator">[docs]</a>	<span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indicator_values</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Applies :attr:`brix.CompositeIndicator.compose_function` to the indicator values to return the composite indicator. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		indicator_values : dict</span>
<span class="sd">			Dictionary with indicator values. See :func:`brix.Handler.get_indicator_values`. </span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		indicator_values : list</span>
<span class="sd">			List of one indicator.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_indicators</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
			<span class="n">indicator_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">indicator_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indicator_values</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_indicators</span><span class="p">}</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose_function</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">)</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">indicator_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indicator_values</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
			<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose_function</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="s1">&#39;raw_value&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span><span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span><span class="s1">&#39;viz_type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">viz_type</span><span class="p">}]</span></div></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, CityScience group at the MIT Media Lab

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>