

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Examples &mdash; cs-brix 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Functions" href="functions.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cs-brix
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#short-examples">Short examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#numeric-indicator-diversity">Numeric indicator: diversity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composite-indicator-average">Composite indicator: average</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heatmap-indicator">Heatmap indicator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-tables-simultaneously">Multiple tables simultaneously</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-by-step-examples">Step by step examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#diversity-of-land-use-indicator-step-by-step">Diversity of land-use indicator - step by step</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composite-indicator-step-by-step-tutorial">Composite indicator – step by step tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heatmap-indicator-step-by-step-tutorial">Heatmap indicator – step by step tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-heatmap-indicator">Static-Heatmap indicator</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cs-brix</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Examples</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/examples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="short-examples">
<h2>Short examples<a class="headerlink" href="#short-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="numeric-indicator-diversity">
<h3>Numeric indicator: diversity<a class="headerlink" href="#numeric-indicator-diversity" title="Permalink to this headline">¶</a></h3>
<p>Indicators are built as subclasses of the :class”<cite>brix.Indicator</cite> class, with three functions that need to be defined: <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a>, <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a>, and <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a>. The function <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> acts like an <strong>init</strong>. It can take any argument and runs when the object is instantiated. The function <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed to run <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> should be passed to <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> and defined as class attributes. The function <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> is the only required one and should take in a <cite>geogrid_data</cite> object (returned from <a class="reference internal" href="classes.html#brix.Handler.get_geogrid_data" title="brix.Handler.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.get_geogrid_data()</span></code></a> or from <a class="reference internal" href="classes.html#brix.Indicator.get_geogrid_data" title="brix.Indicator.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_geogrid_data()</span></code></a>) and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers. Sometimes, the indicator requires geographic information from the table to calculate it. To get geographic information from the table, set the property <code class="xref py py-attr docutils literal notranslate"><span class="pre">brix.Indicator.requires_geometry</span></code> to <cite>True</cite> (see Noise heatmap as an example).</p>
<p>The following example implements a diversity-of-land-use indicator</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Indicator</span>
<span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">class</span> <span class="nc">Diversity</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Entropy&#39;</span>

        <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geogrid_data</span><span class="p">):</span>
                <span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;land_use&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">]</span>
                <span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">use</span> <span class="k">for</span> <span class="n">use</span> <span class="ow">in</span> <span class="n">uses</span> <span class="k">if</span> <span class="n">use</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">]</span>
                <span class="n">frequencies</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">uses</span><span class="p">)</span>
                <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">frequencies</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">entropy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">total</span>
                        <span class="n">entropy</span> <span class="o">+=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">entropy</span>

<span class="n">div</span> <span class="o">=</span> <span class="n">Diversity</span><span class="p">()</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">,</span> <span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="composite-indicator-average">
<h3>Composite indicator: average<a class="headerlink" href="#composite-indicator-average" title="Permalink to this headline">¶</a></h3>
<p>In some settings, it might be useful to aggregate different indicators to get a average feel of what the neighborhood looks like. For this use case, <cite>brix</cite> provides a simplified <cite>CompositeIndicator</cite> class that only needs an aggregation function.</p>
<p>Let’s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact. We use the <a class="reference internal" href="classes.html#brix.CompositeIndicator" title="brix.CompositeIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.CompositeIndicator</span></code></a> class for this. This class takes an aggregate function as input. This function should take the result of <a class="reference internal" href="classes.html#brix.Handler.get_indicator_values" title="brix.Handler.get_indicator_values"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.get_indicator_values()</span></code></a> as input and returns a number. If you want to have more control over what the <a class="reference internal" href="classes.html#brix.CompositeIndicator" title="brix.CompositeIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.CompositeIndicator</span></code></a> does you can always extend the class.</p>
<p>Here is the simplest example that averages the values of three indicators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">CompositeIndicator</span>
<span class="kn">from</span> <span class="nn">brix.examples</span> <span class="kn">import</span> <span class="n">RandomIndicator</span>

<span class="k">def</span> <span class="nf">innovation_average</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">):</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Innovation Potential&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Mobility Impact&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Economic Impact&#39;</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
    <span class="k">return</span> <span class="n">avg</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">RandomIndicator</span><span class="p">()</span>
<span class="n">avg_I</span> <span class="o">=</span> <span class="n">CompositeIndicator</span><span class="p">(</span><span class="n">innovation_average</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Composite&#39;</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicators</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">avg_I</span><span class="p">])</span>
</pre></div>
</div>
<p>In some cases, the aggregation function is too simple to write it again. In the example before, you can also pass it a pre-existing function, such as <cite>np.mean</cite>, making sure that you select the indicators that will be passed as input, by their name.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">CompositeIndicator</span>
<span class="kn">from</span> <span class="nn">brix.examples</span> <span class="kn">import</span> <span class="n">RandomIndicator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">RandomIndicator</span><span class="p">()</span>
<span class="n">avg_I</span> <span class="o">=</span> <span class="n">CompositeIndicator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span><span class="n">selected_indicators</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Innovation Potential&#39;</span><span class="p">,</span><span class="s1">&#39;Mobility Impact&#39;</span><span class="p">,</span><span class="s1">&#39;Economic Impact&#39;</span><span class="p">],</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Composite&#39;</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicators</span><span class="p">([</span><span class="n">R</span><span class="p">,</span><span class="n">avg_I</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="heatmap-indicator">
<h3>Heatmap indicator<a class="headerlink" href="#heatmap-indicator" title="Permalink to this headline">¶</a></h3>
<p>The same class can be used to define a heatmap or accessiblity indicator, as opposed to a numeric indicator. First, set the class property <code class="xref py py-attr docutils literal notranslate"><span class="pre">brix.Indicator.indicator_type</span></code> equal to <cite>heatmap</cite> or to <cite>access</cite>. This will flag the indicator as a heatmap and will tell the Handler class what to do with it.
Second, make sure that the <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> function returns a list of features or a geojson.
The example below shows an indicator that returns noise for every point in the center of a grid cell. Because this indicator needs the coordinates of table to return the geojson, it sets the property <code class="xref py py-attr docutils literal notranslate"><span class="pre">brix.Indicator.requires_geometry</span></code> to <cite>True</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Indicator</span>
<span class="k">class</span> <span class="nc">Noise</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Example of Noise heatmap indicator for points centered in each grid cell.</span>

<span class="sd">        Note that this class requires the geometry of the table as input, which is why it sets:</span>
<span class="sd">        requires_geometry = True</span>
<span class="sd">        in the setup.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="o">=</span> <span class="s1">&#39;heatmap&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">requires_geometry</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geogrid_data</span><span class="p">):</span>
                <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
                        <span class="n">feature</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="n">lat</span><span class="p">,</span><span class="n">lon</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">lat</span><span class="p">,</span><span class="n">lon</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">lat</span><span class="p">),</span><span class="n">mean</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
                        <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;coordinates&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">],</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">}</span>
                        <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="n">random</span><span class="p">()}</span>
                        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;FeatureCollection&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">:</span><span class="n">features</span><span class="p">}</span>
                <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
<div class="section" id="multiple-tables-simultaneously">
<h3>Multiple tables simultaneously<a class="headerlink" href="#multiple-tables-simultaneously" title="Permalink to this headline">¶</a></h3>
<p>The following examples instantiates three <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a> objects for three different tables (<cite>dungeonA</cite>, <cite>dungeonB</cite>, and <cite>dungeonC</cite>) and adds a diversity of land use indicator to each. It then runs <a class="reference internal" href="classes.html#brix.Handler.listen" title="brix.Handler.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.listen()</span></code></a> for each table in its own separate thread.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="kn">from</span> <span class="nn">brix.examples</span> <span class="kn">import</span> <span class="n">Diversity</span><span class="p">,</span> <span class="n">RandomIndicator</span>

<span class="n">table_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dungeona&#39;</span><span class="p">,</span><span class="s1">&#39;dungeonb&#39;</span><span class="p">,</span><span class="s1">&#39;dungeonc&#39;</span><span class="p">]</span>

<span class="n">handler_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">table_name</span> <span class="ow">in</span> <span class="n">table_list</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
        <span class="n">div</span> <span class="o">=</span> <span class="n">Diversity</span><span class="p">()</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">RandomIndicator</span><span class="p">()</span>
        <span class="n">H</span><span class="o">.</span><span class="n">add_indicators</span><span class="p">([</span><span class="n">div</span><span class="p">,</span><span class="n">rand</span><span class="p">])</span>
        <span class="n">handler_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

<span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">handler_list</span><span class="p">:</span>
        <span class="n">h</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="step-by-step-examples">
<h2>Step by step examples<a class="headerlink" href="#step-by-step-examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="diversity-of-land-use-indicator-step-by-step">
<h3>Diversity of land-use indicator - step by step<a class="headerlink" href="#diversity-of-land-use-indicator-step-by-step" title="Permalink to this headline">¶</a></h3>
<p>As an example, we’ll build a diversity of land use indicator for the test table. The process is the same for any table, provided that it has a GEOGRID variable. Indicators are built as subclasses of the <a class="reference internal" href="classes.html#brix.Indicator" title="brix.Indicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Indicator</span></code></a> class, with three functions that need to be defined: <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a>, <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a>, and <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a>. The function <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> acts like an <strong>init</strong>. It can take any argument and runs when the object is instantiated. The function <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed to run <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> should be passed to <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> and defined as class attributes. The function <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> is the only required one and should take in a <cite>geogrid_data</cite> object (returned from <a class="reference internal" href="classes.html#brix.Handler.get_geogrid_data" title="brix.Handler.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.get_geogrid_data()</span></code></a> or from <a class="reference internal" href="classes.html#brix.Indicator.get_geogrid_data" title="brix.Indicator.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_geogrid_data()</span></code></a>) and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers.</p>
<p>To start developing the diversity indicator, you can use the Handler class to get the <code class="docutils literal notranslate"><span class="pre">geogrid_data</span></code> that is an input of the <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geogrid_data</span><span class="p">()</span>
</pre></div>
</div>
<p>The returned <code class="docutils literal notranslate"><span class="pre">geogrid_data</span></code> object depends on the table, but for dungeonmaster it looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
        <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;interactive&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;land_use&#39;</span><span class="p">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tui_id&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">},</span>
        <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">247</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">133</span><span class="p">,</span> <span class="mi">180</span><span class="p">],</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
                <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;interactive&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;land_use&#39;</span><span class="p">:</span> <span class="s1">&#39;PD&#39;</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Office Tower&#39;</span><span class="p">,</span>
                <span class="s1">&#39;old_color&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">133</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">247</span><span class="p">,</span> <span class="mi">180</span><span class="p">],</span>
                <span class="s1">&#39;old_height&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                <span class="s1">&#39;tui_id&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">},</span>
        <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                <span class="s1">&#39;interactive&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;land_use&#39;</span><span class="p">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tui_id&#39;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">},</span>
        <span class="o">...</span>
<span class="p">]</span>
</pre></div>
</div>
<p>We build the diversity indicator by delecting the <code class="docutils literal notranslate"><span class="pre">land_use</span></code> variable in each cell and calculating the Shannon Entropy for this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;land_use&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">]</span>
<span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">use</span> <span class="k">for</span> <span class="n">use</span> <span class="ow">in</span> <span class="n">uses</span> <span class="k">if</span> <span class="n">use</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">]</span>

<span class="n">frequencies</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">uses</span><span class="p">)</span>

<span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">frequencies</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">entropy</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">total</span>
        <span class="n">entropy</span> <span class="o">+=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we wrap this calculation in the <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> in a Diversity class that inherits the properties from the <a class="reference internal" href="classes.html#brix.Indicator" title="brix.Indicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Indicator</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Indicator</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">class</span> <span class="nc">Diversity</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Entropy&#39;</span>

        <span class="k">def</span> <span class="nf">load_module</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geogrid_data</span><span class="p">):</span>
                <span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;land_use&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">]</span>
                <span class="n">uses</span> <span class="o">=</span> <span class="p">[</span><span class="n">use</span> <span class="k">for</span> <span class="n">use</span> <span class="ow">in</span> <span class="n">uses</span> <span class="k">if</span> <span class="n">use</span> <span class="o">!=</span> <span class="s1">&#39;None&#39;</span><span class="p">]</span>

                <span class="n">frequencies</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">uses</span><span class="p">)</span>

                <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">frequencies</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">entropy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="n">total</span>
                        <span class="n">entropy</span> <span class="o">+=</span> <span class="o">-</span><span class="n">p</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">entropy</span>
</pre></div>
</div>
<p>Because this indicator is very simple, it does not need any parameters or data to calculate the value, which is why the <code class="docutils literal notranslate"><span class="pre">load_module</span></code> function is empty. The <code class="docutils literal notranslate"><span class="pre">setup</span></code> function defines the properties of the module, which in this case is just the name.</p>
<p>Finally, we run the indicator by instantiating the new class and passing it to a Handler object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>

<span class="n">div</span> <span class="o">=</span> <span class="n">Diversity</span><span class="p">()</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">,</span> <span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="composite-indicator-step-by-step-tutorial">
<h3>Composite indicator – step by step tutorial<a class="headerlink" href="#composite-indicator-step-by-step-tutorial" title="Permalink to this headline">¶</a></h3>
<p>Let’s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact.
First, we load the RandomIndicator and pass it to a Handler.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">CompositeIndicator</span>
<span class="kn">from</span> <span class="nn">brix.examples</span> <span class="kn">import</span> <span class="n">RandomIndicator</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">RandomIndicator</span><span class="p">()</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
</pre></div>
</div>
<p>To develop the aggregate function, we use the <a class="reference internal" href="classes.html#brix.Handler.get_indicator_values" title="brix.Handler.get_indicator_values"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler.get_indicator_values</span></code></a> function from the handler class. We need to make sure our aggregate function works with that the Handler is returning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">indicator_values</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">get_indicator_values</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">indicator_values</span></code> is a dictionary with the following elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
        <span class="s1">&#39;Social Wellbeing&#39;</span><span class="p">:</span> <span class="mf">0.9302328967423512</span><span class="p">,</span>
        <span class="s1">&#39;Environmental Impact&#39;</span><span class="p">:</span> <span class="mf">0.8229183561962108</span><span class="p">,</span>
        <span class="s1">&#39;Mobility Impact&#39;</span><span class="p">:</span> <span class="mf">0.3880460148817071</span><span class="p">,</span>
        <span class="s1">&#39;Economic Impact&#39;</span><span class="p">:</span> <span class="mf">0.13782084927373295</span><span class="p">,</span>
        <span class="s1">&#39;Innovation Potential&#39;</span><span class="p">:</span> <span class="mf">0.8913823890081203</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We do not need to use all of the values returned by the Handler for our indicator.</p>
<p>Next, we write our simple average function that takes <code class="docutils literal notranslate"><span class="pre">indicator_values</span></code> as input and returns a value, and pass it as an argument to the <a class="reference internal" href="classes.html#brix.CompositeIndicator" title="brix.CompositeIndicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.CompositeIndicator</span></code></a> class constructor.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">innovation_average</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Innovation Potential&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Mobility Impact&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">indicator_values</span><span class="p">[</span><span class="s1">&#39;Economic Impact&#39;</span><span class="p">])</span><span class="o">/</span><span class="mi">3</span>
        <span class="k">return</span> <span class="n">avg</span>

<span class="n">avg_I</span> <span class="o">=</span> <span class="n">CompositeIndicator</span><span class="p">(</span><span class="n">innovation_average</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Composite&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To make sure it is running, we can test it as usual:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avg_I</span><span class="o">.</span><span class="n">return_indicator</span><span class="p">(</span><span class="n">indicator_values</span><span class="p">)</span>
</pre></div>
</div>
<p>We finally add it to the Handler:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">avg_I</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="heatmap-indicator-step-by-step-tutorial">
<h3>Heatmap indicator – step by step tutorial<a class="headerlink" href="#heatmap-indicator-step-by-step-tutorial" title="Permalink to this headline">¶</a></h3>
<p>This section will show you step by step how to build a proximity to parks indicator.</p>
<p>Let’s start by setting up a simple subclass of the Indicator class, give it a name, and set it as a <code class="docutils literal notranslate"><span class="pre">heatmap</span></code> indicator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Indicator</span>
<span class="k">class</span> <span class="nc">ProximityIndicator</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Parks&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="o">=</span> <span class="s1">&#39;heatmap&#39;</span>

        <span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geogrid_data</span><span class="p">):</span>
                <span class="k">pass</span>
</pre></div>
</div>
<p>Next, we link it to the table. This step is only for building the indicator as we use a <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a> object when deploying it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ProximityIndicator</span><span class="p">()</span>
<span class="n">P</span><span class="o">.</span><span class="n">link_table</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">P</span><span class="o">.</span><span class="n">get_geogrid_data</span><span class="p">()</span>
</pre></div>
</div>
<p>When running <a class="reference internal" href="classes.html#brix.Indicator.get_geogrid_data" title="brix.Indicator.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_geogrid_data()</span></code></a> we see that every cell has a <code class="docutils literal notranslate"><span class="pre">name</span></code> property and some cells are classified as <code class="docutils literal notranslate"><span class="pre">Park</span></code>. You’ll also notice that by default, when building a <code class="docutils literal notranslate"><span class="pre">heatmap</span></code> indicator, <code class="docutils literal notranslate"><span class="pre">geogrid_data</span></code> returns the geometries. You can change this behavior by setting <code class="docutils literal notranslate"><span class="pre">self.requires_geometry=False</span></code> in your <code class="docutils literal notranslate"><span class="pre">setup</span></code>.</p>
<p>Next, we define the <code class="docutils literal notranslate"><span class="pre">return_indicator</span></code> function. For debugging and testing you can define this function as stand alone function before adding it as a method to the ProximityIndicator. Some useful functions for debugging are <a class="reference internal" href="classes.html#brix.Indicator.get_geogrid_data" title="brix.Indicator.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_geogrid_data()</span></code></a> and <a class="reference internal" href="classes.html#brix.Indicator.get_table_properties" title="brix.Indicator.get_table_properties"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_table_properties()</span></code></a> that will list general properties of the linked table.</p>
<p>In this example, the proximity indicator is defined as one over the distance to the closest park. When the cell is a park, we define the proximity as 1/(half size of each cell) to avoid dividing by zero.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">geopy.distance</span> <span class="kn">import</span> <span class="n">distance</span> <span class="k">as</span> <span class="n">geodistance</span> <span class="c1"># Function for distance between coordinates</span>

<span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
        <span class="n">parks</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span> <span class="k">if</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Park&#39;</span><span class="p">]</span> <span class="c1"># Find all parks</span>
        <span class="n">parks_locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">parks</span><span class="p">]</span> <span class="c1"># Filter out the center of all park locations (locations are lon,lat format)</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span> <span class="c1"># Calculate a value for the indicator for each cell</span>
                <span class="n">cell_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Calculate center of cell (locations are lon,lat format)</span>
                <span class="k">if</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Park&#39;</span><span class="p">:</span> <span class="c1"># If cell is park, set distance to zero</span>
                        <span class="n">park_distance</span> <span class="o">=</span> <span class="mi">25</span> <span class="c1"># This is based on half the cell size (see P.get_table_properties())</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">geodistance</span><span class="p">(</span><span class="n">cell_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">park_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">park_loc</span> <span class="ow">in</span> <span class="n">parks_locations</span><span class="p">]</span> <span class="c1"># Distance between cell and each park. Notice that we reverse the coordinates for geodistance.</span>
                        <span class="n">park_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># get distance to closest park</span>

                <span class="n">proximity</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">park_distance</span>
                <span class="n">scaled_proximity</span> <span class="o">=</span> <span class="p">(</span><span class="n">proximity</span><span class="o">-</span><span class="mf">0.002</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">0.03</span><span class="o">-</span><span class="mf">0.002</span><span class="p">)</span> <span class="c1"># this ensures the indicator is between zero and one</span>

                <span class="c1"># Generate feature with points (lon,lat format) and properties.</span>
                <span class="n">feature</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;coordinates&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell_coords</span><span class="p">),</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">}</span> <span class="c1"># cell_coords should be a list</span>
                <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">scaled_proximity</span><span class="p">}</span> <span class="c1"># Use the indicator name to tag the value</span>

                <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span> <span class="c1"># add to features list for export</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;FeatureCollection&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">:</span><span class="n">features</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
<p>You can test your function by running: <code class="docutils literal notranslate"><span class="pre">return_indicator(P,geogrid_data)</span></code>.</p>
<p>Finally, let’s put it all together:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Indicator</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">geopy.distance</span> <span class="kn">import</span> <span class="n">distance</span> <span class="k">as</span> <span class="n">geodistance</span>

<span class="k">class</span> <span class="nc">ProximityIndicator</span><span class="p">(</span><span class="n">Indicator</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Parks&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indicator_type</span> <span class="o">=</span> <span class="s1">&#39;heatmap&#39;</span>

        <span class="k">def</span> <span class="nf">return_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">geogrid_data</span><span class="p">):</span>
                <span class="n">parks</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span> <span class="k">if</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Park&#39;</span><span class="p">]</span>
                <span class="n">parks_locations</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">parks</span><span class="p">]</span>

                <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
                        <span class="n">cell_coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Park&#39;</span><span class="p">:</span>
                                <span class="n">park_distance</span> <span class="o">=</span> <span class="mi">45</span>
                        <span class="k">else</span><span class="p">:</span>
                                <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">geodistance</span><span class="p">(</span><span class="n">cell_coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">park_loc</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">park_loc</span> <span class="ow">in</span> <span class="n">parks_locations</span><span class="p">]</span>
                                <span class="n">park_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

                        <span class="n">proximity</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">park_distance</span>
                        <span class="n">scaled_proximity</span> <span class="o">=</span> <span class="p">(</span><span class="n">proximity</span><span class="o">-</span><span class="mf">0.002</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">0.03</span><span class="o">-</span><span class="mf">0.002</span><span class="p">)</span>

                        <span class="n">feature</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;coordinates&#39;</span><span class="p">:</span> <span class="n">cell_coords</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Point&#39;</span><span class="p">}</span>
                        <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">scaled_proximity</span><span class="p">}</span>

                        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>

                <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;FeatureCollection&#39;</span><span class="p">,</span><span class="s1">&#39;features&#39;</span><span class="p">:</span><span class="n">features</span><span class="p">}</span>
                <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
<p>And to deploy it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ProximityIndicator</span><span class="p">()</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="static-heatmap-indicator">
<h3>Static-Heatmap indicator<a class="headerlink" href="#static-heatmap-indicator" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="classes.html#brix.Indicator" title="brix.Indicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Indicator</span></code></a> class provides a flexible way to define any type of indicator. In some cases, a simple approach is needed. Let’s assume we want to build a simple heatmap indicator that just visualizes a given shapefile, and does not react to changes in geogriddata. We can use <a class="reference internal" href="classes.html#brix.StaticHeatmap" title="brix.StaticHeatmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.StaticHeatmap</span></code></a> to build that.</p>
<p>In this example, we will use the number of houses by block in Guadalajara, Mexico. You can download the shapefile from <a class="reference external" href="https://www.inegi.org.mx/contenidos/masiva/indicadores/inv/14_Manzanas_INV2016_shp.zip">HERE</a>. We will not be using our trusted <cite>dungeonmaster</cite> table, as it does not overlap with the data. Instead we will use <cite>jalisco</cite>.</p>
<p>The first step will be to “griddify” our shapefile, meaning we will transform it from polygons to sampling points. Please note that you can use any sampling method for this, and that the sampling points do not need to match the grid. To make things easier, we have provided <a class="reference internal" href="functions.html#brix.griddify" title="brix.griddify"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.griddify()</span></code></a>, which uses the centroids of the grid to sample the values of the heatmap.</p>
<p>We start by loading the shapefile and removing the missing values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="n">shapefile</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">&#39;/Users/username/Downloads/14_Manzanas_INV2016_shp/14_Manzanas_INV2016.shp&#39;</span><span class="p">)</span>
<span class="n">shapefile</span> <span class="o">=</span> <span class="n">shapefile</span><span class="p">[</span><span class="n">shapefile</span><span class="p">[</span><span class="s1">&#39;VIVTOT&#39;</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;N.D.&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Since the <cite>VIVTOT</cite> column that we are interested in visualizing has a skewed distribution, we will log-transform it.</p>
<dl class="simple">
<dt>::</dt><dd><p>import numpy as np
shapefile[‘log_VIVTOT’] = np.log(shapefile[‘VIVTOT’]+1)</p>
</dd>
</dl>
<p>Next, we load a table and use its grid to sample the heatmap.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;jalisco&#39;</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
<span class="n">geogrid_data</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">get_geogrid_data</span><span class="p">()</span>
</pre></div>
</div>
<p>The next step is to use the grid to sample the values of the heatmap. We will use the <cite>log_VIVTOT</cite> column, and save the resulting heatmap to a file so we can load it later. We will also remove the missing values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">griddify</span>
<span class="n">heatmap</span> <span class="o">=</span> <span class="n">griddify</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span><span class="n">shapefile</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;log_VIVTOT&#39;</span><span class="p">])</span>
<span class="n">heatmap</span> <span class="o">=</span> <span class="n">heatmap</span><span class="p">[</span><span class="o">~</span><span class="n">heatmap</span><span class="p">[</span><span class="s1">&#39;log_VIVTOT&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>
<span class="n">heatmap</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This shapefile is a table of points and their properties. To build your indicator you can either load the file and pass it to the :class:brix.StaticHeatmap` constructor, or have the constructor load it for you.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">StaticHeatmap</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">StaticHeatmap</span><span class="p">(</span><span class="s1">&#39;/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp&#39;</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;log_VIVTOT&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Finally, we add it to a Handler class and check the update package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">update_package</span><span class="p">()</span>
</pre></div>
</div>
<p>To wrap up, once the <cite>heatmap</cite> file has been saved, all you need to do deploy the indicator is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">StaticHeatmap</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;jalisco&#39;</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">StaticHeatmap</span><span class="p">(</span><span class="s1">&#39;/Users/username/Downloads/14_Manzanas_INV2016_shp/HEATMAP.shp&#39;</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;log_VIVTOT&#39;</span><span class="p">])</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="functions.html" class="btn btn-neutral float-left" title="Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, CityScience group at the MIT Media Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>