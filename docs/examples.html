

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Examples &mdash; cs-brix 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Classes" href="classes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> cs-brix
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#numeric-indicator-diversity">Numeric indicator: diversity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id29">]</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id56">}</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cs-brix</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Examples</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/examples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="numeric-indicator-diversity">
<h2>Numeric indicator: diversity<a class="headerlink" href="#numeric-indicator-diversity" title="Permalink to this headline">¶</a></h2>
<p>Indicators are built as subclasses of the :class”<cite>brix.Indicator</cite> class, with three functions that need to be defined: <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a>, <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a>, and <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a>. The function <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> acts like an <strong>init</strong>. It can take any argument and runs when the object is instantiated. The function <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed to run <a class="reference internal" href="classes.html#brix.Indicator.load_module" title="brix.Indicator.load_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.load_module()</span></code></a> should be passed to <a class="reference internal" href="classes.html#brix.Indicator.setup" title="brix.Indicator.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.setup()</span></code></a> and defined as class attributes. The function <a class="reference internal" href="classes.html#brix.Indicator.return_indicator" title="brix.Indicator.return_indicator"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.return_indicator()</span></code></a> is the only required one and should take in a <cite>geogrid_data</cite> object (returned from <a class="reference internal" href="classes.html#brix.Handler.get_geogrid_data" title="brix.Handler.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.get_geogrid_data()</span></code></a> or from <a class="reference internal" href="classes.html#brix.Indicator.get_geogrid_data" title="brix.Indicator.get_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Indicator.get_geogrid_data()</span></code></a>) and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers. Sometimes, the indicator requires geographic information from the table to calculate it. To get geographic information from the table, set the property <code class="xref py py-attr docutils literal notranslate"><span class="pre">brix.Indicator.requires_geometry</span></code> to <cite>True</cite> (see Noise heatmap as an example).</p>
<p>The following example implements a diversity-of-land-use indicator:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
from brix import Indicator
from brix import Handler</p>
<p>from numpy import log
from collections import Counter</p>
<p>class Diversity(Indicator):</p>
<blockquote>
<div><dl>
<dt>def setup(self):</dt><dd><p>self.name = ‘Entropy’</p>
</dd>
<dt>def load_module(self):</dt><dd><p>pass</p>
</dd>
<dt>def return_indicator(self, geogrid_data):</dt><dd><p>uses = [cell[‘land_use’] for cell in geogrid_data]
uses = [use for use in uses if use != ‘None’]</p>
<p>frequencies = Counter(uses)
total = sum(frequencies.values(), 0.0)
entropy = 0
for key in frequencies:</p>
<blockquote>
<div><p>p = frequencies[key]/total
entropy += -p*log(p)</p>
</div></blockquote>
<p>return entropy</p>
</dd>
</dl>
</div></blockquote>
<p>div = Diversity()</p>
<p>H = Handler(‘dungeonmaster’, quietly=False)
H.add_indicator(div)
H.listen()
<a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<p>### Composite indicator: average</p>
<p>In some settings, it might be useful to aggregate different indicators to get a average feel of what the neighborhood looks like. For this use case, <cite>brix</cite> provides a simplified <cite>CompositeIndicator</cite> class that only needs an aggregation function.</p>
<p>Let’s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact. We use the <cite>CompositeIndicator</cite> class for this. This class takes an aggregate function as input. This function should take the result of <cite>Handler.get_indicator_values()</cite> as input and returns a number. If you want to have more control over what the <cite>CompositeIndicator</cite> does you can always extend the class.</p>
<p>Here is the simplest example that averages the values of three indicators:</p>
<p><a href="#id7"><span class="problematic" id="id8">``</span></a>`
from brix import Handler, CompositeIndicator
from brix.examples import RandomIndicator</p>
<dl class="simple">
<dt>def innovation_average(indicator_values):</dt><dd><p>avg = (indicator_values[‘Innovation Potential’]+indicator_values[‘Mobility Impact’]+indicator_values[‘Economic Impact’])/3
return avg</p>
</dd>
</dl>
<p>H = Handler(‘dungeonmaster’)
R = RandomIndicator()
avg_I = CompositeIndicator(innovation_average,name=’Composite’)
H.add_indicators([R,avg_I])
<a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a></p>
<p>In some cases, the aggregation function is too simple to write it again. In the example before, you can also pass it a pre-existing function, such as <cite>np.mean</cite>, making sure that you select the indicators that will be passed as input, by their name.</p>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a>`
from brix import Handler, CompositeIndicator
from brix.examples import RandomIndicator
import numpy as np</p>
<p>H = Handler(‘dungeonmaster’)
R = RandomIndicator()
avg_I = CompositeIndicator(np.mean,selected_indicators=[‘Innovation Potential’,’Mobility Impact’,’Economic Impact’],name=’Composite’)
H.add_indicators([R,avg_I])
<a href="#id15"><span class="problematic" id="id16">``</span></a><a href="#id17"><span class="problematic" id="id18">`</span></a></p>
<p>### Heatmap indicator</p>
<p>The same class can be used to define a heatmap or accessiblity indicator, as opposed to a numeric indicator.
First, set the class property _indicator_type_ equal to ‘heatmap’ or to ‘access’. This will flag the indicator as a heatmap and will tell the Handler class what to do with it.
Second, make sure that the _return_indicator_ function returns a list of features or a geojson.
The example below shows an indicator that returns noise for every point in the center of a grid cell. Because this indicator needs the coordinates of table to return the geojson, it sets the property _requires_geometry_ to True.</p>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a>`
from brix import Indicator
class Noise(Indicator):</p>
<blockquote>
<div><p>‘’’
Example of Noise heatmap indicator for points centered in each grid cell.</p>
<p>Note that this class requires the geometry of the table as input, which is why it sets:
requires_geometry = True
in the setup.</p>
<p>‘’’
def setup(self):</p>
<blockquote>
<div><p>self.indicator_type = ‘heatmap’
self.requires_geometry = True</p>
</div></blockquote>
<dl>
<dt>def load_module(self):</dt><dd><p>pass</p>
</dd>
<dt>def return_indicator(self, geogrid_data):</dt><dd><p>features = []
for cell in geogrid_data:</p>
<blockquote>
<div><p>feature = {}
lat,lon = zip(<a href="#id21"><span class="problematic" id="id22">*</span></a>cell[‘geometry’][‘coordinates’][0])
lat,lon = mean(lat),mean(lon)
feature[‘geometry’] = {‘coordinates’: [lat,lon],’type’: ‘Point’}
feature[‘properties’] = {self.name:random()}
features.append(feature)</p>
</div></blockquote>
<p>out = {‘type’:’FeatureCollection’,’features’:features}
return out</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a></p>
<p>## Step by step examples</p>
<p>### Diversity of land-use indicator - step by step</p>
<p>As an example, we’ll build a diversity of land use indicator for the test table. The process is the same for any table, provided that it has a GEOGRID variable. Indicators are built as subclasses of the <strong>Indicator</strong> class, with three functions that need to be defined: _setup_, _load_module_, and _return_indicator_. The function _setup_ acts like an _**init**_ and can take any argument and is run when the object is instantiated. The function _load_module_ is also run when the indicator in initialized, but it cannot take any arguments. Any inputs needed for _load_module_ should be defined as properties in _setup_. The function _return_indicator_ is the only required one and should take in a ‘geogrid_data’ object and return the value of the indicator either as a number, a dictionary, or a list of dictionaries/numbers.</p>
<p>To start developing the diversity indicator, you can use the Handler class to get the geogrid*data that is an input of the _return_indicator* function.</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">from</span> <span class="pre">brix</span> <span class="pre">import</span> <span class="pre">Handler</span>
<span class="pre">H</span> <span class="pre">=</span> <span class="pre">Handler('dungeonmaster')</span>
<span class="pre">geogrid_data</span> <span class="pre">=</span> <span class="pre">H.geogrid_data()</span>
<span class="pre">`</span></code></p>
<p>The returned _geogrid_data_ object depends on the table, but for dungeonmaster it looks like this:</p>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a>`
[</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>‘color’: [0, 0, 0, 0],
‘height’: 0.1,
‘id’: 0,
‘interactive’: True,
‘land_use’: ‘None’,
‘name’: ‘empty’,
‘tui_id’: None</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>‘color’: [247, 94, 133, 180],
‘height’: [0, 80],
‘id’: 1,
‘interactive’: True,
‘land_use’: ‘PD’,
‘name’: ‘Office Tower’,
‘old_color’: [133, 94, 247, 180],
‘old_height’: [0, 10],
‘tui_id’: None</p>
</div></blockquote>
<p>},
{</p>
<blockquote>
<div><p>‘color’: [0, 0, 0, 0],
‘height’: 0.1,
‘id’: 2,
‘interactive’: True,
‘land_use’: ‘None’,
‘name’: ‘empty’,
‘tui_id’: None</p>
</div></blockquote>
</div></blockquote>
<div class="section" id="id29">
<h3>]<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>We build the diversity indicator by delecting the ‘land_use’ variable in each cell and calculating the Shannon Entropy for this:</p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a>`
from numpy import log
from collections import Counter
uses = [cell[‘land_use’] for cell in geogrid_data]
uses = [use for use in uses if use != ‘None’]</p>
<p>frequencies = Counter(uses)</p>
<p>total = sum(frequencies.values(), 0.0)
entropy = 0
for key in frequencies:</p>
<blockquote>
<div><p>p = frequencies[key]/total
entropy += -p*log(p)</p>
</div></blockquote>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a></p>
<p>Now, we wrap this calculation in the _return_indicator_ in a Diversity class that inherits the properties from the Indicator module:</p>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a>`
from brix import Indicator
from numpy import log
from collections import Counter</p>
<p>class Diversity(Indicator):</p>
<blockquote>
<div><dl>
<dt>def setup(self):</dt><dd><p>self.name = ‘Entropy’</p>
</dd>
<dt>def load_module(self):</dt><dd><p>pass</p>
</dd>
<dt>def return_indicator(self, geogrid_data):</dt><dd><p>uses = [cell[‘land_use’] for cell in geogrid_data]
uses = [use for use in uses if use != ‘None’]</p>
<p>frequencies = Counter(uses)</p>
<p>total = sum(frequencies.values(), 0.0)
entropy = 0
for key in frequencies:</p>
<blockquote>
<div><p>p = frequencies[key]/total
entropy += -p*log(p)</p>
</div></blockquote>
<p>return entropy</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a></p>
<p>Because this indicator is very simple, it does not need any parameters or data to calculate the value, which is why the _load_module_ function is empty. The _setup_ function defines the properties of the module, which in this case is just the name.</p>
<p>Finally, we run the indicator by instantiating the new class and passing it to a Handler object:</p>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a>`
from brix import Handler</p>
<p>div = Diversity()</p>
<p>H = Handler(‘dungeonmaster’, quietly=False)
H.add_indicator(div)
H.listen()
<a href="#id44"><span class="problematic" id="id45">``</span></a><a href="#id46"><span class="problematic" id="id47">`</span></a></p>
<p>### Composite indicator – step by step tutorial</p>
<p>Let’s create an indicator that averages Innovation Potential, Mobility Inmpact, and Economic Impact.
First, we load the RandomIndicator and pass it to a Handler.</p>
<p><a href="#id48"><span class="problematic" id="id49">``</span></a>`
from brix import Handler, CompositeIndicator
from brix.examples import RandomIndicator</p>
<p>H = Handler(‘dungeonmaster’)
R = RandomIndicator()
H.add_indicator(R)
<a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>To develop the aggregate function, we use the <cite>get_indicator_values()</cite> function from the handler class. We need to make sure our aggregate function works with that the Handler is returning:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">indicator_values</span> <span class="pre">=</span> <span class="pre">H.get_indicator_values()</span>
<span class="pre">`</span></code></p>
<p>In this case, the <cite>indicator_values</cite> is a dictionary with the following elements:</p>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a>`
{</p>
<blockquote>
<div><p>‘Social Wellbeing’: 0.9302328967423512,
‘Environmental Impact’: 0.8229183561962108,
‘Mobility Impact’: 0.3880460148817071,
‘Economic Impact’: 0.13782084927373295,
‘Innovation Potential’: 0.8913823890081203</p>
</div></blockquote>
</div>
<div class="section" id="id56">
<h3>}<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h3>
<p>We do not need to use all of the values returned by the Handler for our indicator. </p>
<p>Next, we write our simple average function that takes <cite>indicator_values</cite> as input and returns a value, and pass it as an argument to the <cite>CompositeIndicator</cite> class constructor.</p>
<p><a href="#id57"><span class="problematic" id="id58">``</span></a>`
def innovation_average(indicator_values):</p>
<blockquote>
<div><p>avg = (indicator_values[‘Innovation Potential’]+indicator_values[‘Mobility Impact’]+indicator_values[‘Economic Impact’])/3
return avg</p>
</div></blockquote>
<p>avg_I = CompositeIndicator(innovation_average,name=’Composite’)
<a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a></p>
<p>To make sure it is running, we can test it as usual:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">avg_I.return_indicator(indicator_values)</span>
<span class="pre">`</span></code></p>
<p>We finally add it to the Handler:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">H.add_indicator(avg_I)</span>
<span class="pre">`</span></code></p>
<p>### Heatmap indicator – step by step tutorial</p>
<p>This section will show you step by step how to build a proximity to parks indicator.</p>
<p>Let’s start by setting up a simple subclass of the Indicator class, give it a name, and set it as a <cite>heatmap</cite> indicator:
<a href="#id63"><span class="problematic" id="id64">``</span></a>`
from brix import Indicator
class ProximityIndicator(Indicator):</p>
<blockquote>
<div><dl class="simple">
<dt>def setup(self):</dt><dd><p>self.name = ‘Parks’
self.indicator_type = ‘heatmap’</p>
</dd>
<dt>def return_indicator(self, geogrid_data):</dt><dd><p>pass</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<p>Next, we link it to the table. This step is only for building the indicator as we use a <cite>Handler</cite> object when deploying it.</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">P</span> <span class="pre">=</span> <span class="pre">ProximityIndicator()</span>
<span class="pre">P.link_table('dungeonmaster')</span>
<span class="pre">P.get_geogrid_data()</span>
<span class="pre">`</span></code>
When running <cite>get_geogrid_data</cite> we see that every cell has a <cite>name</cite> property and some cells are classified as <cite>Park</cite>. You’ll also notice that by default, when building a <cite>heatmap</cite> indicator, <cite>geogrid_data</cite> returns the geometries. You can change this behavior by setting <cite>self.requires_geometry=False</cite> in your <cite>setup</cite>.</p>
<p>Next, we define the <cite>return_indicator</cite> function. For debugging and testing you can define this function as stand alone function before adding it as a method to the ProximityIndicator. Some useful functions for debugging are <cite>P.get_geogrid_data()</cite> and <cite>P.get_table_properties()</cite> that will list general properties of the linked table.</p>
<p>In this example, the proximity indicator is defined as one over the distance to the closest park. When the cell is a park, we define the proximity as 1/(half size of each cell) to avoid dividing by zero.</p>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a>`
import numpy as np
from geopy.distance import distance as geodistance # Function for distance between coordinates</p>
<dl>
<dt>def return_indicator(self,geogrid_data):</dt><dd><p>parks = [cell for cell in geogrid_data if cell[‘name’]==’Park’] # Find all parks
parks_locations = [np.mean(cell[‘geometry’][‘coordinates’][0],0) for cell in parks] # Filter out the center of all park locations (locations are lon,lat format)</p>
<p>features = []
for cell in geogrid_data: # Calculate a value for the indicator for each cell</p>
<blockquote>
<div><p>cell_coords = np.mean(cell[‘geometry’][‘coordinates’][0],0) # Calculate center of cell (locations are lon,lat format)
if cell[‘name’]==’Park’: # If cell is park, set distance to zero</p>
<blockquote>
<div><p>park_distance = 25 # This is based on half the cell size (see P.get_table_properties())</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>distances = [geodistance(cell_coords[::-1],park_loc[::-1]).m for park_loc in parks_locations] # Distance between cell and each park. Notice that we reverse the coordinates for geodistance.
park_distance = min(distances) # get distance to closest park</p>
</dd>
</dl>
<p>proximity = 1/park_distance
scaled_proximity = (proximity-0.002)/(0.03-0.002) # this ensures the indicator is between zero and one</p>
<p># Generate feature with points (lon,lat format) and properties.
feature = {}
feature[‘geometry’] = {‘coordinates’: list(cell_coords),’type’: ‘Point’} # cell_coords should be a list
feature[‘properties’] = {self.name: scaled_proximity} # Use the indicator name to tag the value</p>
<p>features.append(feature) # add to features list for export</p>
</div></blockquote>
<p>out = {‘type’:’FeatureCollection’,’features’:features}
return out</p>
</dd>
</dl>
<p><a href="#id71"><span class="problematic" id="id72">``</span></a><a href="#id73"><span class="problematic" id="id74">`</span></a></p>
<p>You can test your function by running: <cite>return_indicator(P,geogrid_data)</cite>.</p>
<p>Finally, let’s put it all together:
<a href="#id75"><span class="problematic" id="id76">``</span></a>`
from brix import Indicator
import numpy as np
from geopy.distance import distance as geodistance</p>
<dl>
<dt>class ProximityIndicator(Indicator):</dt><dd><dl>
<dt>def setup(self):</dt><dd><p>self.name = ‘Parks’
self.indicator_type = ‘heatmap’</p>
</dd>
<dt>def return_indicator(self,geogrid_data):</dt><dd><p>parks = [cell for cell in geogrid_data if cell[‘name’]==’Park’]
parks_locations = [np.mean(cell[‘geometry’][‘coordinates’][0],0) for cell in parks]</p>
<p>features = []
for cell in geogrid_data:</p>
<blockquote>
<div><p>cell_coords = list(np.mean(cell[‘geometry’][‘coordinates’][0],0) )
if cell[‘name’]==’Park’:</p>
<blockquote>
<div><p>park_distance = 45</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>distances = [geodistance(cell_coords[::-1],park_loc[::-1]).m for park_loc in parks_locations]
park_distance = min(distances)</p>
</dd>
</dl>
<p>proximity = 1/park_distance
scaled_proximity = (proximity-0.002)/(0.03-0.002)</p>
<p>feature = {}
feature[‘geometry’] = {‘coordinates’: cell_coords,’type’: ‘Point’}
feature[‘properties’] = {self.name: scaled_proximity}</p>
<p>features.append(feature)</p>
</div></blockquote>
<p>out = {‘type’:’FeatureCollection’,’features’:features}
return out</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a></p>
<p>And to deploy it:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">from</span> <span class="pre">brix</span> <span class="pre">import</span> <span class="pre">Handler</span>
<span class="pre">H</span> <span class="pre">=</span> <span class="pre">Handler('dungeonmaster')</span>
<span class="pre">P</span> <span class="pre">=</span> <span class="pre">ProximityIndicator()</span>
<span class="pre">H.add_indicator(P)</span>
<span class="pre">H.listen()</span>
<span class="pre">`</span></code></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="classes.html" class="btn btn-neutral float-left" title="Classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, CityScience group at the MIT Media Lab

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>