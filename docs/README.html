

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Introduction &mdash; cs-brix 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cs-brix
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cs-brix</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/README.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Brix is a python library for CityScope modules which handles communication with <a class="reference external" href="http://cityio.media.mit.edu/">City I/O</a>.</p>
<p>Full documentation can be found <a class="reference external" href="https://cityscope.media.mit.edu/CS_Brix/">here</a>.</p>
<p>Please note that <cite>brix</cite> is still being developed, which is why some features might change fairly quickly. You can follow the updates by keeping track of <cite>brix</cite> development in the <a class="reference external" href="https://github.com/CityScope/CS_Brix">github repo</a>.</p>
<div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>What is this library for? If you have never heard of a CityScope before, you might want to stop reading and learn about them <a class="reference external" href="https://cityscope.media.mit.edu/">here</a>. CityScope is an awesome way to interact, explore, and co-create urban interventions in a way that can be accessed by multiple people with different background. If you know what they are, please keep reading.</p>
<p>What is a CityScope table? a ‘table’ is our way of describing a CityScope project. Why table then? Since historically, most CityScope instances were composed of a mesh between a physical table-top 3D model of a city, augmented with projections, software, and other interface hardware. So a table =&gt; project.</p>
<p>What is an indicator? An indicator is the result of running a module for CityScope. Indicators work by listening for updated from the CityScope table they are linked to, calculating some values by using a model, some function of the data, or a simulation, and then post the result of the calculations to CityIO to be displayed in the table.</p>
<p>What are the types of indicators you can build? Indicators can be anything that could be displayed on a CityScope table, including the supporting screens associated to it. For the purpose of this library, we distinguish three types of indicator: numeric, heatmap, simulation.</p>
<ul class="simple">
<li><p>Numeric: Numeric indicators are just a number or set of numbers. They are usually displayed in a chart (bar chart, radar chart, etc) next to the table. The most common numeric indicator are the numbers that go in the radar plot, which display information about density, diversity, and proximity.</p></li>
<li><p>Heatmap: These indicators are geodata. They are made up of geometries (points, lines, or polygons) and properties associated to them. These indicators are displayed as layers directly on the CityScope table.</p></li>
<li><p>Simulation: These type of indicators are also displayed on the table but they are the result of an agent based simulation and are therefore displayed as a dynamic layer. They change over time like a short movie. These are not yet supported by this library.</p></li>
</ul>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<p>Brix is now on pip. Just do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">cs</span><span class="o">-</span><span class="n">brix</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorials">
<h1>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this headline">¶</a></h1>
<p>This module also contains a set of other useful functions that integrate with <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a> and <a class="reference internal" href="classes.html#brix.Indicator" title="brix.Indicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Indicator</span></code></a>.</p>
<p>The functions <a class="reference internal" href="functions.html#brix.get_OSM_geometries" title="brix.get_OSM_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.get_OSM_geometries()</span></code></a> and <a class="reference internal" href="functions.html#brix.get_OSM_nodes" title="brix.get_OSM_nodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.get_OSM_nodes()</span></code></a> help you get data from Open Street Maps for your table.</p>
<div class="section" id="auto-updates-of-geogriddata">
<h2>Auto-updates of GEOGRIDDATA<a class="headerlink" href="#auto-updates-of-geogriddata" title="Permalink to this headline">¶</a></h2>
<p>Brix also has the capability of automatically updating GEOGRIDDATA. For simple one-time updates, follow the documentation of <a class="reference internal" href="classes.html#brix.Handler.update_geogrid_data" title="brix.Handler.update_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.update_geogrid_data()</span></code></a>. To use this feeature, you first need to define a function that takes a <a class="reference internal" href="classes.html#brix.GEOGRIDDATA" title="brix.GEOGRIDDATA"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.GEOGRIDDATA</span></code></a> as an input. When used with <a class="reference internal" href="classes.html#brix.Handler.update_geogrid_data" title="brix.Handler.update_geogrid_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.update_geogrid_data()</span></code></a>, this function can take any number of keyword arguments. The following example raises the height of all cells by 3 units:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_height</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
                <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">levels</span>
        <span class="k">return</span> <span class="n">geogrid_data</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="s1">&#39;dungeonmaster&#39;</span><span class="p">,</span> <span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">update_geogrid_data</span><span class="p">(</span><span class="n">add_height</span><span class="p">,</span><span class="n">levels</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Brix also supports GEOGRIDDATA updates everytime there is a registered user interaction in the front end. To add a function to the update schedule, use <a class="reference internal" href="classes.html#brix.Handler.add_geogrid_data_update_function" title="brix.Handler.add_geogrid_data_update_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.add_geogrid_data_update_function()</span></code></a>. This has the limitation that your update funcion cannot take in any arguments other. If this limitation proves too restrictive, please submit an issue and we’ll consider pushing an update.</p>
<p>The following example updates the whole grid to <cite>Light Industrial</cite> use everytime there’s a user interaction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_g</span><span class="p">(</span><span class="n">geogrid_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">geogrid_data</span><span class="p">:</span>
                <span class="n">cell</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Light Industrial&#39;</span>
        <span class="k">return</span> <span class="n">geogrid_data</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span><span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_geogrid_data_update_function</span><span class="p">(</span><span class="n">update_g</span><span class="p">)</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
<p>The updates triggered by <a class="reference internal" href="classes.html#brix.Handler.listen" title="brix.Handler.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.listen()</span></code></a> follow the following order:</p>
<ol class="arabic simple">
<li><p>get GEOGRIDDATA</p></li>
<li><p>run all GEOGRIDDATA updates using the result of 1 as input</p></li>
<li><p>get the new GEOGRIDDATA</p></li>
<li><p>update all indicators using the GEOGRIDDATA object resulting from 3</p></li>
</ol>
</div>
<div class="section" id="creating-a-table-from-python">
<h2>Creating a table from python<a class="headerlink" href="#creating-a-table-from-python" title="Permalink to this headline">¶</a></h2>
<p><cite>Brix</cite> provides a class for creating spatial grids for CityScope projects: <code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Grid_maker</span></code> a subclass of <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a>.</p>
<p>For most use cases, you will create your table using the web-app editor found <a class="reference external" href="https://cityscope.media.mit.edu/CS_cityscopeJS/#/editor">here</a>. For more complex projects, you might need to create your own table from an existing dataset. For example, you might want to select the grid area using a polygon defined in a shapefile. The tools we highlight here can be use for this purpose.</p>
<p>The first step is to instantiate the class by defining the location of your table and its name. The lat,lon provided to the <code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Grid_maker</span></code> constructor correspond to the top left corner of the grid (North-West).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Grid_maker</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;dungeonmaster&#39;</span>
<span class="n">lat</span><span class="p">,</span><span class="n">lon</span> <span class="o">=</span> <span class="mf">42.361875</span><span class="p">,</span> <span class="o">-</span><span class="mf">71.105713</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Grid_maker</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>
</pre></div>
</div>
<p>If the table already exists, you can either use <a class="reference internal" href="classes.html#brix.Handler.delete_table" title="brix.Handler.delete_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.delete_table()</span></code></a> to delete it or wait to be prompted if you want to rewrite it. You can check if the table exists by using <a class="reference internal" href="classes.html#brix.Handler.is_table" title="brix.Handler.is_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Handler.is_table()</span></code></a>. Please note that since <code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Grid_maker</span></code> is a subclass of <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a>, most functions available for a <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a> object are also available for a <code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Grid_maker</span></code> object. The table constructor also allows you to specify the <cite>cell_size</cite>, the <cite>nrows</cite> and <cite>ncols</cite>, as well as other parameters.</p>
<p>Once the grid maker object has been instatiated, we set the grid by running <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.set_grid_geojson()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">set_grid_geojson</span><span class="p">()</span>
</pre></div>
</div>
<p>This will create the geojson that will be posted to CityIO to create the table. You can check the object by using <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.get_grid_geojson()</span></code>.</p>
<p>The next step is to define the cell types that the user will be able to choose frorm. Defining the necessary types and the properties of each type is a very complex process that involves data collection and analysis as well as community engagement and simulation that is beyond the scope of this tutorial. The default table created with the Grid constructor only contains a simple type called <cite>Default</cite>. To see this, you can use <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.grid_types()</span></code>. If you wish to change this, you can use <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.edit_types()</span></code>. This function will either take a json-like object (dict of dicts) with the name of the type as the key, or a list of names of types that will be automatically completed with default values. Once the types have been defined, they can be expressed in the following way, adding as many properties as needed by your table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
        <span class="s1">&#39;Default&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;interactive&#39;</span><span class="p">:</span> <span class="s1">&#39;Web&#39;</span><span class="p">,</span>
                <span class="o">...</span>
        <span class="p">},</span>
        <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bare minimum properties that need to be defined are <cite>color</cite>, <cite>height</cite>, and <cite>interactive</cite>. If not provided, <cite>brix</cite> will assign them automatically.</p>
<p>The following line of code replaces the <cite>Default</cite> type by there other cell types callsed <cite>Type 1</cite>, <cite>Type 2</cite>, and <cite>Type 3</cite>, letting brix assign the color to each of them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">edit_types</span><span class="p">([</span><span class="s1">&#39;Type 1&#39;</span><span class="p">,</span><span class="s1">&#39;Type 2&#39;</span><span class="p">,</span><span class="s1">&#39;Type 3&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>For most applications, you will want to turn off some of the cells and make them non-interactive. Usually, this will involve a shapefile or a geojson that contains the polygon that defines the interactive part of the table. If you have a Shapely polygon stored in <cite>poly</cite> you can set the non-interactive cells by using <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.set_noninteractive()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">set_noninteractive</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
</pre></div>
</div>
<p>The final step is to commit the grid to CityIO. Use <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.Grid_maker.commit_grid()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">commit_grid</span><span class="p">()</span>
</pre></div>
</div>
<p>Putting it all together:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Grid_maker</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;dungeonmaster&#39;</span>
<span class="n">lat</span><span class="p">,</span><span class="n">lon</span> <span class="o">=</span> <span class="mf">42.361875</span><span class="p">,</span> <span class="o">-</span><span class="mf">71.105713</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Grid_maker</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">set_grid_geojson</span><span class="p">()</span>
<span class="n">G</span><span class="o">.</span><span class="n">edit_types</span><span class="p">([</span><span class="s1">&#39;Type 1&#39;</span><span class="p">,</span><span class="s1">&#39;Type 2&#39;</span><span class="p">,</span><span class="s1">&#39;Type 3&#39;</span><span class="p">])</span>
<span class="n">G</span><span class="o">.</span><span class="n">set_noninteractive</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">commit_grid</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, you can use <cite>poly</cite> as an argument to <code class="xref py py-func docutils literal notranslate"><span class="pre">brix.grid_from_poly()</span></code>. This function will calculate the location and the cell size based on the given polygon, and set the non-interactive parts. The following block of code achieves the same as the block above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Grid_maker</span><span class="p">,</span> <span class="n">grid_from_poly</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;dungeonmaster&#39;</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">grid_from_poly</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">poly</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">edit_types</span><span class="p">([</span><span class="s1">&#39;Type 1&#39;</span><span class="p">,</span><span class="s1">&#39;Type 2&#39;</span><span class="p">,</span><span class="s1">&#39;Type 3&#39;</span><span class="p">])</span>
<span class="n">G</span><span class="o">.</span><span class="n">commit_grid</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-your-module">
<h2>Testing your module<a class="headerlink" href="#testing-your-module" title="Permalink to this headline">¶</a></h2>
<p>To automatically test your module, this library provides the <a class="reference internal" href="classes.html#brix.User" title="brix.User"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.User</span></code></a> class that simulates the behavior of a user interacting with your grid. This user runs in its own new thread to free up your main thread so that you can keep wokring on your indicator.</p>
<p>The following example consists of a <a class="reference internal" href="classes.html#brix.Handler" title="brix.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Handler</span></code></a> that contains a diversity <a class="reference internal" href="classes.html#brix.Indicator" title="brix.Indicator"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.Indicator</span></code></a> that reponds to the updates of the <a class="reference internal" href="classes.html#brix.User" title="brix.User"><code class="xref py py-class docutils literal notranslate"><span class="pre">brix.User</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">brix</span> <span class="kn">import</span> <span class="n">Handler</span>
<span class="kn">from</span> <span class="nn">brix.examples</span> <span class="kn">import</span> <span class="n">Diversity</span>
<span class="kn">from</span> <span class="nn">brix.test_tools</span> <span class="kn">import</span> <span class="n">User</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s1">&#39;dungeonmaster&#39;</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span><span class="n">quietly</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">div</span> <span class="o">=</span> <span class="n">Diversity</span><span class="p">()</span>
<span class="n">H</span><span class="o">.</span><span class="n">add_indicator</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>
<span class="n">U</span><span class="o">.</span><span class="n">start_user</span><span class="p">()</span>
<span class="n">H</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, CityScience group at the MIT Media Lab.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>